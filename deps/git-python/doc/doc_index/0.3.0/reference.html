<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Reference &mdash; GitPython v0.3.0-beta2 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '0.3.0-beta2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="GitPython v0.3.0-beta2 documentation" href="index.html" />
    <link rel="next" title="Roadmap" href="roadmap.html" />
    <link rel="prev" title="GitPython Tutorial" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="roadmap.html" title="Roadmap"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="GitPython Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">GitPython v0.3.0-beta2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api-reference">
<span id="api-reference-toplevel"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-git.objects.base">
<h2>Objects.Base<a class="headerlink" href="#module-git.objects.base" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.base.Object">
<em class="property">class </em><tt class="descclassname">git.objects.base.</tt><tt class="descname">Object</tt><big>(</big><em>repo</em>, <em>binsha</em><big>)</big><a class="headerlink" href="#git.objects.base.Object" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Object which may be Blobs, Trees, Commits and Tags</p>
<dl class="attribute">
<dt id="git.objects.base.Object.binsha">
<tt class="descname">binsha</tt><a class="headerlink" href="#git.objects.base.Object.binsha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.data_stream">
<tt class="descname">data_stream</tt><a class="headerlink" href="#git.objects.base.Object.data_stream" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">File Object compatible stream to the uncompressed raw data of the object</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">returned streams must be read in order</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.hexsha">
<tt class="descname">hexsha</tt><a class="headerlink" href="#git.objects.base.Object.hexsha" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">40 byte hex version of our 20 byte binary sha</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.base.Object.new">
<em class="property">classmethod </em><tt class="descname">new</tt><big>(</big><em>repo</em>, <em>id</em><big>)</big><a class="headerlink" href="#git.objects.base.Object.new" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">New Object instance of a type appropriate to the object type behind 
id. The id of the newly created object will be a binsha even though 
the input id may have been a Reference or Rev-Spec</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>id</em> &#8211; reference, rev-spec, or hexsha</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This cannot be a __new__ method as it would always call __init__
with the input id which is not necessarily a binsha.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.base.Object.new_from_sha">
<em class="property">classmethod </em><tt class="descname">new_from_sha</tt><big>(</big><em>repo</em>, <em>sha1</em><big>)</big><a class="headerlink" href="#git.objects.base.Object.new_from_sha" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new object instance of a type appropriate to represent the given 
binary sha1</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>sha1</em> &#8211; 20 byte binary sha1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.objects.base.Object.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.size">
<tt class="descname">size</tt><a class="headerlink" href="#git.objects.base.Object.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.objects.base.Object.stream_data">
<tt class="descname">stream_data</tt><big>(</big><em>ostream</em><big>)</big><a class="headerlink" href="#git.objects.base.Object.stream_data" title="Permalink to this definition">¶</a></dt>
<dd>Writes our data directly to the given output stream
:param ostream: File object compatible stream object.
:return: self</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.objects.base.IndexObject">
<em class="property">class </em><tt class="descclassname">git.objects.base.</tt><tt class="descname">IndexObject</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>mode=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.base.IndexObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Base for all objects that can be part of the index file , namely Tree, Blob and
SubModule objects</p>
<dl class="attribute">
<dt id="git.objects.base.IndexObject.abspath">
<tt class="descname">abspath</tt><a class="headerlink" href="#git.objects.base.IndexObject.abspath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Absolute path to this index object in the file system ( as opposed to the 
.path field which is a path relative to the git repository ).</p>
<p class="last">The returned path will be native to the system and contains &#8216;&#8217; on windows.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#git.objects.base.IndexObject.mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.objects.base.IndexObject.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Name portion of the path, effectively being the basename</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.objects.base.IndexObject.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.blob">
<h2>Objects.Blob<a class="headerlink" href="#module-git.objects.blob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.blob.Blob">
<em class="property">class </em><tt class="descclassname">git.objects.blob.</tt><tt class="descname">Blob</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>mode=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.blob.Blob" title="Permalink to this definition">¶</a></dt>
<dd><p>A Blob encapsulates a git blob object</p>
<dl class="attribute">
<dt id="git.objects.blob.Blob.mime_type">
<tt class="descname">mime_type</tt><a class="headerlink" href="#git.objects.blob.Blob.mime_type" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">String describing the mime type of this file (based on the filename)</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Defaults to &#8216;text/plain&#8217; in case the actual file type is unknown.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.commit">
<h2>Objects.Commit<a class="headerlink" href="#module-git.objects.commit" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.commit.Commit">
<em class="property">class </em><tt class="descclassname">git.objects.commit.</tt><tt class="descname">Commit</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>tree=None</em>, <em>author=None</em>, <em>authored_date=None</em>, <em>author_tz_offset=None</em>, <em>committer=None</em>, <em>committed_date=None</em>, <em>committer_tz_offset=None</em>, <em>message=None</em>, <em>parents=None</em>, <em>encoding=None</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a git Commit object.</p>
<p>This class will act lazily on some of its attributes and will query the 
value on demand only if it involves calling the git binary.</p>
<dl class="attribute">
<dt id="git.objects.commit.Commit.author">
<tt class="descname">author</tt><a class="headerlink" href="#git.objects.commit.Commit.author" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.author_tz_offset">
<tt class="descname">author_tz_offset</tt><a class="headerlink" href="#git.objects.commit.Commit.author_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.authored_date">
<tt class="descname">authored_date</tt><a class="headerlink" href="#git.objects.commit.Commit.authored_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committed_date">
<tt class="descname">committed_date</tt><a class="headerlink" href="#git.objects.commit.Commit.committed_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committer">
<tt class="descname">committer</tt><a class="headerlink" href="#git.objects.commit.Commit.committer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committer_tz_offset">
<tt class="descname">committer_tz_offset</tt><a class="headerlink" href="#git.objects.commit.Commit.committer_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.objects.commit.Commit.count">
<tt class="descname">count</tt><big>(</big><em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of commits reachable from this commit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>paths</em> &#8211; is an optinal path or a list of paths restricting the return value 
to commits actually containing the paths</li>
<li><em>kwargs</em> &#8211; Additional options to be passed to git-rev-list. They must not alter
the ouput style of the command, or parsing will yield incorrect results</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">int defining the number of reachable commits</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.commit.Commit.create_from_tree">
<em class="property">classmethod </em><tt class="descname">create_from_tree</tt><big>(</big><em>repo</em>, <em>tree</em>, <em>message</em>, <em>parent_commits=None</em>, <em>head=False</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.create_from_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the given tree, creating a commit object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; Repo object the commit should be part of</li>
<li><em>tree</em> &#8211; Tree object or hex or bin sha 
the tree of the new commit</li>
<li><em>message</em> &#8211; Commit message. It may be an empty string if no message is provided.
It will be converted to a string in any case.</li>
<li><em>parent_commits</em> &#8211; Optional Commit objects to use as parents for the new commit.
If empty list, the commit will have no parents at all and become 
a root commit.
If None , the current head commit will be the parent of the 
new commit object</li>
<li><em>head</em> &#8211; If True, the HEAD will be advanced to the new commit automatically.
Else the HEAD will remain pointing on the previous commit. This could 
lead to undesired results when diffing files.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Commit object representing the new commit</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">Additional information about the committer and Author are taken from the
environment or from the git configuration, see git-commit-tree for 
more information</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.encoding">
<tt class="descname">encoding</tt><a class="headerlink" href="#git.objects.commit.Commit.encoding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.objects.commit.Commit.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>rev</em>, <em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all commits matching the given criteria.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; is the Repo</li>
<li><em>rev</em> &#8211; revision specifier, see git-rev-parse for viable options</li>
<li><em>paths</em> &#8211; is an optinal path or list of paths, if set only Commits that include the path 
or paths will be considered</li>
<li><em>kwargs</em> &#8211; optional keyword arguments to git rev-list where
<tt class="docutils literal"><span class="pre">max_count</span></tt> is the maximum number of commits to fetch
<tt class="docutils literal"><span class="pre">skip</span></tt> is the number of commits to skip
<tt class="docutils literal"><span class="pre">since</span></tt> all commits since i.e. &#8216;1970-01-01&#8217;</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">iterator yielding Commit items</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.objects.commit.Commit.iter_parents">
<tt class="descname">iter_parents</tt><big>(</big><em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.iter_parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate _all_ parents of this commit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>paths</em> &#8211; Optional path or list of paths limiting the Commits to those that 
contain at least one of the paths</li>
<li><em>kwargs</em> &#8211; All arguments allowed by git-rev-list</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator yielding Commit objects which are parents of self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.message">
<tt class="descname">message</tt><a class="headerlink" href="#git.objects.commit.Commit.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.name_rev">
<tt class="descname">name_rev</tt><a class="headerlink" href="#git.objects.commit.Commit.name_rev" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">String describing the commits hex sha based on the closest Reference.
Mostly useful for UI purposes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.parents">
<tt class="descname">parents</tt><a class="headerlink" href="#git.objects.commit.Commit.parents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.stats">
<tt class="descname">stats</tt><a class="headerlink" href="#git.objects.commit.Commit.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a git stat from changes between this commit and its first parent 
or from all changes done if this is the very first commit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">git.Stats</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.summary">
<tt class="descname">summary</tt><a class="headerlink" href="#git.objects.commit.Commit.summary" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">First line of the commit message</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.tree">
<tt class="descname">tree</tt><a class="headerlink" href="#git.objects.commit.Commit.tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.tag">
<h2>Objects.Tag<a class="headerlink" href="#module-git.objects.tag" title="Permalink to this headline">¶</a></h2>
<p>Module containing all object based types.</p>
<dl class="class">
<dt id="git.objects.tag.TagObject">
<em class="property">class </em><tt class="descclassname">git.objects.tag.</tt><tt class="descname">TagObject</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>object=None</em>, <em>tag=None</em>, <em>tagger=None</em>, <em>tagged_date=None</em>, <em>tagger_tz_offset=None</em>, <em>message=None</em><big>)</big><a class="headerlink" href="#git.objects.tag.TagObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-Lightweight tag carrying additional information about an object we are pointing to.</p>
<dl class="attribute">
<dt id="git.objects.tag.TagObject.message">
<tt class="descname">message</tt><a class="headerlink" href="#git.objects.tag.TagObject.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.object">
<tt class="descname">object</tt><a class="headerlink" href="#git.objects.tag.TagObject.object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tag">
<tt class="descname">tag</tt><a class="headerlink" href="#git.objects.tag.TagObject.tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagged_date">
<tt class="descname">tagged_date</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagged_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagger">
<tt class="descname">tagger</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagger_tz_offset">
<tt class="descname">tagger_tz_offset</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagger_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.tree">
<h2>Objects.Tree<a class="headerlink" href="#module-git.objects.tree" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.tree.TreeModifier">
<em class="property">class </em><tt class="descclassname">git.objects.tree.</tt><tt class="descname">TreeModifier</tt><big>(</big><em>cache</em><big>)</big><a class="headerlink" href="#git.objects.tree.TreeModifier" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility class providing methods to alter the underlying cache in a list-like fashion.</p>
<p>Once all adjustments are complete, the _cache, which really is a refernce to 
the cache of a tree, will be sorted. Assuring it will be in a serializable state</p>
<dl class="method">
<dt id="git.objects.tree.TreeModifier.add">
<tt class="descname">add</tt><big>(</big><em>sha</em>, <em>mode</em>, <em>name</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.objects.tree.TreeModifier.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given item to the tree. If an item with the given name already
exists, nothing will be done, but a ValueError will be raised if the 
sha and mode of the existing item do not match the one you add, unless 
force is True</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>sha</em> &#8211; The 20 or 40 byte sha of the item to add</li>
<li><em>mode</em> &#8211; int representing the stat compatible mode of the item</li>
<li><em>force</em> &#8211; If True, an item with your name and information will overwrite
any existing item with the same name, no matter which information it has</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.objects.tree.TreeModifier.add_unchecked">
<tt class="descname">add_unchecked</tt><big>(</big><em>binsha</em>, <em>mode</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.objects.tree.TreeModifier.add_unchecked" title="Permalink to this definition">¶</a></dt>
<dd>Add the given item to the tree, its correctness is assumed, which 
puts the caller into responsibility to assure the input is correct. 
For more information on the parameters, see <tt class="docutils literal"><span class="pre">add</span></tt>
:param binsha: 20 byte binary sha</dd></dl>

<dl class="method">
<dt id="git.objects.tree.TreeModifier.set_done">
<tt class="descname">set_done</tt><big>(</big><big>)</big><a class="headerlink" href="#git.objects.tree.TreeModifier.set_done" title="Permalink to this definition">¶</a></dt>
<dd>Call this method once you are done modifying the tree information.
It may be called several times, but be aware that each call will cause 
a sort operation
:return self:</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.objects.tree.Tree">
<em class="property">class </em><tt class="descclassname">git.objects.tree.</tt><tt class="descname">Tree</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>mode=16384</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.tree.Tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Tree objects represent an ordered list of Blobs and other Trees.</p>
<p><tt class="docutils literal"><span class="pre">Tree</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">list</span></tt>:</p>
<div class="highlight-python"><pre>Access a specific blob using the  
tree['filename'] notation.

You may as well access by index
blob = tree[0]</pre>
</div>
<dl class="attribute">
<dt id="git.objects.tree.Tree.blobs">
<tt class="descname">blobs</tt><a class="headerlink" href="#git.objects.tree.Tree.blobs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list(Blob, ...) list of blobs directly below this tree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.tree.Tree.cache">
<tt class="descname">cache</tt><a class="headerlink" href="#git.objects.tree.Tree.cache" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An object allowing to modify the internal cache. This can be used
to change the tree&#8217;s contents. When done, make sure you call <tt class="docutils literal"><span class="pre">set_done</span></tt>
on the tree modifier, or serialization behaviour will be incorrect.
See the <tt class="docutils literal"><span class="pre">TreeModifier</span></tt> for more information on how to alter the cache</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.objects.tree.Tree.traverse">
<tt class="descname">traverse</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x26386e0&gt;</em>, <em>prune=&lt;function &lt;lambda&gt; at 0x2638758&gt;</em>, <em>depth=-1</em>, <em>branch_first=True</em>, <em>visit_once=False</em>, <em>ignore_self=1</em><big>)</big><a class="headerlink" href="#git.objects.tree.Tree.traverse" title="Permalink to this definition">¶</a></dt>
<dd>For documentation, see util.Traversable.traverse
Trees are set to visit_once = False to gain more performance in the traversal</dd></dl>

<dl class="attribute">
<dt id="git.objects.tree.Tree.trees">
<tt class="descname">trees</tt><a class="headerlink" href="#git.objects.tree.Tree.trees" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list(Tree, ...) list of trees directly below this tree</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.fun">
<h2>Objects.Functions<a class="headerlink" href="#module-git.objects.fun" title="Permalink to this headline">¶</a></h2>
<p>Module with functions which are supposed to be as fast as possible</p>
<dl class="function">
<dt id="git.objects.fun.tree_to_stream">
<tt class="descclassname">git.objects.fun.</tt><tt class="descname">tree_to_stream</tt><big>(</big><em>entries</em>, <em>write</em><big>)</big><a class="headerlink" href="#git.objects.fun.tree_to_stream" title="Permalink to this definition">¶</a></dt>
<dd>Write the give list of entries into a stream using its write method
:param entries: <strong>sorted</strong> list of tuples with (binsha, mode, name)
:param write: write method which takes a data string</dd></dl>

<dl class="function">
<dt id="git.objects.fun.tree_entries_from_data">
<tt class="descclassname">git.objects.fun.</tt><tt class="descname">tree_entries_from_data</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#git.objects.fun.tree_entries_from_data" title="Permalink to this definition">¶</a></dt>
<dd>Reads the binary representation of a tree and returns tuples of Tree items
:param data: data block with tree data
:return: list(tuple(binsha, mode, tree_relative_path), ...)</dd></dl>

<dl class="function">
<dt id="git.objects.fun.traverse_trees_recursive">
<tt class="descclassname">git.objects.fun.</tt><tt class="descname">traverse_trees_recursive</tt><big>(</big><em>odb</em>, <em>tree_shas</em>, <em>path_prefix</em><big>)</big><a class="headerlink" href="#git.objects.fun.traverse_trees_recursive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list with entries according to the given binary tree-shas. 
The result is encoded in a list
of n tuple|None per blob/commit, (n == len(tree_shas)), where 
* [0] == 20 byte sha
* [1] == mode as int
* [2] == path relative to working tree root
The entry tuple is None if the respective blob/commit did not 
exist in the given tree.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>tree_shas</em> &#8211; iterable of shas pointing to trees. All trees must 
be on the same level. A tree-sha may be None in which case None</li>
<li><em>path_prefix</em> &#8211; a prefix to be added to the returned paths on this level, 
set it &#8216;&#8217; for the first iteration</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">The ordering of the returned items will be partially lost</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.objects.fun.traverse_tree_recursive">
<tt class="descclassname">git.objects.fun.</tt><tt class="descname">traverse_tree_recursive</tt><big>(</big><em>odb</em>, <em>tree_sha</em>, <em>path_prefix</em><big>)</big><a class="headerlink" href="#git.objects.fun.traverse_tree_recursive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of entries of the tree pointed to by the binary tree_sha. An entry
has the following format:
* [0] 20 byte sha
* [1] mode as int
* [2] path relative to the repository</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>path_prefix</em> &#8211; prefix to prepend to the front of all returned paths</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-git.objects.submodule">
<h2>Objects.Submodule<a class="headerlink" href="#module-git.objects.submodule" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.submodule.Submodule">
<em class="property">class </em><tt class="descclassname">git.objects.submodule.</tt><tt class="descname">Submodule</tt><big>(</big><em>repo</em>, <em>binsha</em>, <em>mode=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.submodule.Submodule" title="Permalink to this definition">¶</a></dt>
<dd>Implements access to a git submodule. They are special in that their sha
represents a commit in the submodule&#8217;s repository which is to be checked out
at the path of this instance. 
The submodule type does not have a string type associated with it, as it exists
solely as a marker in the tree and index</dd></dl>

</div>
<div class="section" id="module-git.objects.util">
<h2>Objects.Util<a class="headerlink" href="#module-git.objects.util" title="Permalink to this headline">¶</a></h2>
<p>Module for general utility functions</p>
<dl class="function">
<dt id="git.objects.util.get_object_type_by_name">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">get_object_type_by_name</tt><big>(</big><em>object_type_name</em><big>)</big><a class="headerlink" href="#git.objects.util.get_object_type_by_name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">type suitable to handle the given object type name.
Use the type to create new instances.</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>object_type_name</em> &#8211; Member of TYPES</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">In case object_type_name is unknown</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.objects.util.get_user_id">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">get_user_id</tt><big>(</big><big>)</big><a class="headerlink" href="#git.objects.util.get_user_id" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">string identifying the currently active system user as <a class="reference external" href="mailto:name&#37;&#52;&#48;node">name<span>&#64;</span>node</a></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">user can be set with the &#8216;USER&#8217; environment variable, usually set on windows</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.objects.util.parse_date">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">parse_date</tt><big>(</big><em>string_date</em><big>)</big><a class="headerlink" href="#git.objects.util.parse_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the given date as one of the following</p>
<blockquote>
<ul>
<li><p class="first">Git internal format: timestamp offset</p>
</li>
<li><p class="first">RFC 2822: Thu, 07 Apr 2005 22:13:13 +0200.</p>
</li>
<li><dl class="first docutils">
<dt>ISO 8601 2005-04-07T22:13:13</dt>
<dd><p class="first last">The T can be a space as well</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Tuple(int(timestamp), int(offset)), both in seconds since epoch</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">If the format could not be understood</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Date can also be YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.objects.util.parse_actor_and_date">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">parse_actor_and_date</tt><big>(</big><em>line</em><big>)</big><a class="headerlink" href="#git.objects.util.parse_actor_and_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse out the actor (author or committer) info from a line like:</p>
<div class="highlight-python"><pre>author Tom Preston-Werner &lt;tom@mojombo.com&gt; 1191999972 -0700</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">[Actor, int_seconds_since_epoch, int_timezone_offset]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="git.objects.util.ProcessStreamAdapter">
<em class="property">class </em><tt class="descclassname">git.objects.util.</tt><tt class="descname">ProcessStreamAdapter</tt><big>(</big><em>process</em>, <em>stream_name</em><big>)</big><a class="headerlink" href="#git.objects.util.ProcessStreamAdapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Class wireing all calls to the contained Process instance.</p>
<p>Use this type to hide the underlying process to provide access only to a specified 
stream. The process is usually wrapped into an AutoInterrupt class to kill 
it if the instance goes out of scope.</p>
</dd></dl>

<dl class="class">
<dt id="git.objects.util.Traversable">
<em class="property">class </em><tt class="descclassname">git.objects.util.</tt><tt class="descname">Traversable</tt><a class="headerlink" href="#git.objects.util.Traversable" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple interface to perforam depth-first or breadth-first traversals 
into one direction.
Subclasses only need to implement one function.
Instances of the Subclass must be hashable</p>
<dl class="method">
<dt id="git.objects.util.Traversable.traverse">
<tt class="descname">traverse</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2627c08&gt;</em>, <em>prune=&lt;function &lt;lambda&gt; at 0x2627c80&gt;</em>, <em>depth=-1</em>, <em>branch_first=True</em>, <em>visit_once=True</em>, <em>ignore_self=1</em>, <em>as_edge=False</em><big>)</big><a class="headerlink" href="#git.objects.util.Traversable.traverse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">iterator yieling of items found when traversing self</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>predicate</em> &#8211; f(i,d) returns False if item i at depth d should not be included in the result</li>
<li><em>prune</em> &#8211; f(i,d) return True if the search should stop at item i at depth d.
Item i will not be returned.</li>
<li><em>depth</em> &#8211; define at which level the iteration should not go deeper
if -1, there is no limit
if 0, you would effectively only get self, the root of the iteration
i.e. if 1, you would only get the first level of predessessors/successors</li>
<li><em>branch_first</em> &#8211; if True, items will be returned branch first, otherwise depth first</li>
<li><em>visit_once</em> &#8211; if True, items will only be returned once, although they might be encountered
several times. Loops are prevented that way.</li>
<li><em>ignore_self</em> &#8211; if True, self will be ignored and automatically pruned from
the result. Otherwise it will be the first item to be returned.
If as_edge is True, the source of the first edge is None</li>
<li><em>as_edge</em> &#8211; if True, return a pair of items, first being the source, second the 
destinatination, i.e. tuple(src, dest) with the edge spanning from 
source to destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.objects.util.altz_to_utctz_str">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">altz_to_utctz_str</tt><big>(</big><em>altz</em><big>)</big><a class="headerlink" href="#git.objects.util.altz_to_utctz_str" title="Permalink to this definition">¶</a></dt>
<dd>As above, but inverses the operation, returning a string that can be used
in commit objects</dd></dl>

<dl class="function">
<dt id="git.objects.util.utctz_to_altz">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">utctz_to_altz</tt><big>(</big><em>utctz</em><big>)</big><a class="headerlink" href="#git.objects.util.utctz_to_altz" title="Permalink to this definition">¶</a></dt>
<dd>we convert utctz to the timezone in seconds, it is the format time.altzone
returns. Git stores it as UTC timezon which has the opposite sign as well, 
which explains the -1 * ( that was made explicit here )
:param utctz: git utc timezone string, i.e. +0200</dd></dl>

<dl class="function">
<dt id="git.objects.util.verify_utctz">
<tt class="descclassname">git.objects.util.</tt><tt class="descname">verify_utctz</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#git.objects.util.verify_utctz" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if offset is incorrect</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">offset</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-git.index.base">
<h2>Index.Base<a class="headerlink" href="#module-git.index.base" title="Permalink to this headline">¶</a></h2>
<p>Module containing Index implementation, allowing to perform all kinds of index
manipulations such as querying and merging.</p>
<dl class="class">
<dt id="git.index.base.IndexFile">
<em class="property">class </em><tt class="descclassname">git.index.base.</tt><tt class="descname">IndexFile</tt><big>(</big><em>repo</em>, <em>file_path=None</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Index that can be manipulated using a native implementation in
order to save git command function calls wherever possible.</p>
<p>It provides custom merging facilities allowing to merge without actually changing
your index or your working tree. This way you can perform own test-merges based
on the index only without having to deal with the working copy. This is useful
in case of partial working trees.</p>
<p><tt class="docutils literal"><span class="pre">Entries</span></tt></p>
<p>The index contains an entries dict whose keys are tuples of type IndexEntry
to facilitate access.</p>
<p>You may read the entries dict or manipulate it using IndexEntry instance, i.e.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">index</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">entry_key</span><span class="p">(</span><span class="n">index_entry_instance</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index_entry_instance</span>
</pre></div>
</div>
<p>Make sure you use index.write() once you are done manipulating the index directly
before operating on it using the git command</p>
<dl class="method">
<dt id="git.index.base.IndexFile.add">
<tt class="descname">add</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.checkout">
<tt class="descname">checkout</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.checkout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.commit">
<tt class="descname">commit</tt><big>(</big><em>message</em>, <em>parent_commits=None</em>, <em>head=True</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the current default index file, creating a commit object.</p>
<p>For more information on the arguments, see tree.commit.
:note:</p>
<blockquote>
If you have manually altered the .entries member of this instance,
don&#8217;t forget to write() your changes to disk beforehand.</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Commit object representing the new commit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.diff">
<tt class="descname">diff</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.base.IndexFile.entries">
<tt class="descname">entries</tt><a class="headerlink" href="#git.index.base.IndexFile.entries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.index.base.IndexFile.entry_key">
<em class="property">classmethod </em><tt class="descname">entry_key</tt><big>(</big><em>*entry</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.entry_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.index.base.IndexFile.from_tree">
<em class="property">classmethod </em><tt class="descname">from_tree</tt><big>(</big><em>repo</em>, <em>*treeish</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.from_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the given treeish revisions into a new index which is returned.
The original index will remain unaltered</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; The repository treeish are located in.</li>
<li><em>treeish</em> &#8211; <p>One, two or three Tree Objects, Commits or 40 byte hexshas. The result
changes according to the amount of trees.
If 1 Tree is given, it will just be read into a new index
If 2 Trees are given, they will be merged into a new index using a</p>
<blockquote>
two way merge algorithm. Tree 1 is the &#8216;current&#8217; tree, tree 2 is the &#8216;other&#8217;
one. It behaves like a fast-forward.
If 3 Trees are given, a 3-way merge will be performed with the first tree
being the common ancestor of tree 2 and tree 3. Tree 2 is the &#8216;current&#8217; tree,
tree 3 is the &#8216;other&#8217; one</blockquote>
</li>
<li><em>kwargs</em> &#8211; Additional arguments passed to git-read-tree</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New IndexFile instance. It will point to a temporary index location which
does not exist anymore. If you intend to write such a merged Index, supply
an alternate file_path to its &#8216;write&#8217; method.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">In the three-way merge case, &#8211;aggressive will be specified to automatically
resolve more cases in a commonly correct manner. Specify trivial=True as kwarg
to override that.</p>
<p class="last">As the underlying git-read-tree command takes into account the current index,
it will be temporarily moved out of the way to assure there are no unsuspected
interferences.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.iter_blobs">
<tt class="descname">iter_blobs</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x26abed8&gt;</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.iter_blobs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator yielding tuples of Blob objects and stages, tuple(stage, Blob)</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; Function(t) returning True if tuple(stage, Blob) should be yielded by the
iterator. A default filter, the BlobFilter, allows you to yield blobs
only if they match a given list of paths.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.merge_tree">
<tt class="descname">merge_tree</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.merge_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.move">
<tt class="descname">move</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.move" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.index.base.IndexFile.new">
<em class="property">classmethod </em><tt class="descname">new</tt><big>(</big><em>repo</em>, <em>*tree_sha</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the given treeish revisions into a new index which is returned.
This method behaves like git-read-tree &#8211;aggressive when doing the merge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; The repository treeish are located in.</li>
<li><em>tree_sha</em> &#8211; 20 byte or 40 byte tree sha or tree objects</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">New IndexFile instance. Its path will be undefined. 
If you intend to write such a merged Index, supply an alternate file_path 
to its &#8216;write&#8217; method.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.base.IndexFile.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.index.base.IndexFile.path" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Path to the index file we are representing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.remove">
<tt class="descname">remove</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.base.IndexFile.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.index.base.IndexFile.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.reset">
<tt class="descname">reset</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.resolve_blobs">
<tt class="descname">resolve_blobs</tt><big>(</big><em>iter_blobs</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.resolve_blobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the blobs given in blob iterator. This will effectively remove the
index entries of the respective path at all non-null stages and add the given
blob as new stage null blob.</p>
<p>For each path there may only be one blob, otherwise a ValueError will be raised
claiming the path is already at stage 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if one of the blobs already existed at stage 0</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">You will have to write the index manually once you are done, i.e.
index.resolve_blobs(blobs).write()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.unmerged_blobs">
<tt class="descname">unmerged_blobs</tt><big>(</big><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.unmerged_blobs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator yielding dict(path : list( tuple( stage, Blob, ...))), being
a dictionary associating a path in the index with a list containing
sorted stage/blob pairs</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Blobs that have been removed in one side simply do not exist in the
given stage. I.e. a file removed on the &#8216;other&#8217; branch whose entries
are at stage 3 will not have a stage 3 entry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Reread the contents of our index file, discarding all cached information
we might have.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This is a possibly dangerious operations as it will discard your changes
to index.entries</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.base.IndexFile.version">
<tt class="descname">version</tt><a class="headerlink" href="#git.index.base.IndexFile.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.write">
<tt class="descname">write</tt><big>(</big><em>file_path=None</em>, <em>ignore_tree_extension_data=False</em><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the current state to our file path or to the given one</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>file_path</em> &#8211; If None, we will write to our stored file path from which we have
been initialized. Otherwise we write to the given file path.
Please note that this will change the file_path of this index to
the one you gave.</li>
<li><em>ignore_tree_extension_data</em> &#8211; If True, the TREE type extension data read in the index will not
be written to disk. Use this if you have altered the index and
would like to use git-write-tree afterwards to create a tree
representing your written changes.
If this data is present in the written index, git-write-tree
will instead write the stored/cached tree.
Alternatively, use IndexFile.write_tree() to handle this case
automatically</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.base.IndexFile.write_tree">
<tt class="descname">write_tree</tt><big>(</big><big>)</big><a class="headerlink" href="#git.index.base.IndexFile.write_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes this index to a corresponding Tree object into the repository&#8217;s
object database and return it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Tree object representing this index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">The tree will be written even if one or more objects the tree refers to 
does not yet exist in the object database. This could happen if you added
Entries to the index directly.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if there are no entries in the cache</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises UnmergedEntriesError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="git.index.base.CheckoutError">
<em class="property">exception </em><tt class="descclassname">git.index.base.</tt><tt class="descname">CheckoutError</tt><big>(</big><em>message</em>, <em>failed_files</em>, <em>valid_files</em>, <em>failed_reasons</em><big>)</big><a class="headerlink" href="#git.index.base.CheckoutError" title="Permalink to this definition">¶</a></dt>
<dd><p>Thrown if a file could not be checked out from the index as it contained
changes.</p>
<p>The .failed_files attribute contains a list of relative paths that failed
to be checked out as they contained changes that did not exist in the index.</p>
<p>The .failed_reasons attribute contains a string informing about the actual
cause of the issue.</p>
<p>The .valid_files attribute contains a list of relative paths to files that
were checked out successfully and hence match the version stored in the
index</p>
</dd></dl>

</div>
<div class="section" id="module-git.index.fun">
<h2>Index.Functions<a class="headerlink" href="#module-git.index.fun" title="Permalink to this headline">¶</a></h2>
<p>Contains standalone functions to accompany the index implementation and make it
more versatile</p>
<dl class="function">
<dt id="git.index.fun.write_cache">
<tt class="descclassname">git.index.fun.</tt><tt class="descname">write_cache</tt><big>(</big><em>entries</em>, <em>stream</em>, <em>extension_data=None</em>, <em>ShaStreamCls=&lt;class 'git.util.IndexFileSHA1Writer'&gt;</em><big>)</big><a class="headerlink" href="#git.index.fun.write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the cache represented by entries to a stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>entries</em> &#8211; <strong>sorted</strong> list of entries</li>
<li><em>stream</em> &#8211; stream to wrap into the AdapterStreamCls - it is used for
final output.</li>
<li><em>ShaStreamCls</em> &#8211; Type to use when writing to the stream. It produces a sha
while writing to it, before the data is passed on to the wrapped stream</li>
<li><em>extension_data</em> &#8211; any kind of data to write as a trailer, it must begin
a 4 byte identifier, followed by its size ( 4 bytes )</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.index.fun.read_cache">
<tt class="descclassname">git.index.fun.</tt><tt class="descname">read_cache</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#git.index.fun.read_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a cache file from the given stream
:return: tuple(version, entries_dict, extension_data, content_sha)</p>
<blockquote>
<ul>
<li><p class="first">version is the integer version number</p>
</li>
<li><dl class="first docutils">
<dt>entries dict is a dictionary which maps IndexEntry instances to a path</dt>
<dd><p class="first last">at a stage</p>
</dd>
</dl>
</li>
<li><p class="first">extension_data is &#8216;&#8217; or 4 bytes of type + 4 bytes of size + size bytes</p>
</li>
<li><p class="first">content_sha is a 20 byte sha on all cache file contents</p>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="function">
<dt id="git.index.fun.write_tree_from_cache">
<tt class="descclassname">git.index.fun.</tt><tt class="descname">write_tree_from_cache</tt><big>(</big><em>entries</em>, <em>odb</em>, <em>sl</em>, <em>si=0</em><big>)</big><a class="headerlink" href="#git.index.fun.write_tree_from_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tree from the given sorted list of entries and put the respective
trees into the given object database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>entries</em> &#8211; <strong>sorted</strong> list of IndexEntries</li>
<li><em>odb</em> &#8211; object database to store the trees in</li>
<li><em>si</em> &#8211; start index at which we should start creating subtrees</li>
<li><em>sl</em> &#8211; slice indicating the range we should process on the entries list</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple(binsha, list(tree_entry, ...)) a tuple of a sha and a list of 
tree entries being a tuple of hexsha, mode, name</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.index.fun.entry_key">
<tt class="descclassname">git.index.fun.</tt><tt class="descname">entry_key</tt><big>(</big><em>*entry</em><big>)</big><a class="headerlink" href="#git.index.fun.entry_key" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Key suitable to be used for the index.entries dictionary</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>entry</em> &#8211; One instance of type BaseIndexEntry or the path and the stage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.index.fun.stat_mode_to_index_mode">
<tt class="descclassname">git.index.fun.</tt><tt class="descname">stat_mode_to_index_mode</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#git.index.fun.stat_mode_to_index_mode" title="Permalink to this definition">¶</a></dt>
<dd>Convert the given mode from a stat call to the corresponding index mode
and return it</dd></dl>

</div>
<div class="section" id="module-git.index.typ">
<h2>Index.Types<a class="headerlink" href="#module-git.index.typ" title="Permalink to this headline">¶</a></h2>
<p>Module with additional types used by the index</p>
<dl class="class">
<dt id="git.index.typ.BlobFilter">
<em class="property">class </em><tt class="descclassname">git.index.typ.</tt><tt class="descname">BlobFilter</tt><big>(</big><em>paths</em><big>)</big><a class="headerlink" href="#git.index.typ.BlobFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to be used by iter_blobs allowing to filter only return blobs which
match the given list of directories or files.</p>
<p>The given paths are given relative to the repository.</p>
<dl class="attribute">
<dt id="git.index.typ.BlobFilter.paths">
<tt class="descname">paths</tt><a class="headerlink" href="#git.index.typ.BlobFilter.paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.index.typ.BaseIndexEntry">
<em class="property">class </em><tt class="descclassname">git.index.typ.</tt><tt class="descname">BaseIndexEntry</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Small Brother of an index entry which can be created to describe changes
done to the index in which case plenty of additional information is not requried.</p>
<p>As the first 4 data members match exactly to the IndexEntry type, methods
expecting a BaseIndexEntry can also handle full IndexEntries even if they
use numeric indices for performance reasons.</p>
<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.binsha">
<tt class="descname">binsha</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.binsha" title="Permalink to this definition">¶</a></dt>
<dd>binary sha of the blob</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.flags">
<tt class="descname">flags</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.flags" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">flags stored with this entry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.index.typ.BaseIndexEntry.from_blob">
<em class="property">classmethod </em><tt class="descname">from_blob</tt><big>(</big><em>blob</em>, <em>stage=0</em><big>)</big><a class="headerlink" href="#git.index.typ.BaseIndexEntry.from_blob" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Fully equipped BaseIndexEntry at the given stage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.hexsha">
<tt class="descname">hexsha</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.hexsha" title="Permalink to this definition">¶</a></dt>
<dd>hex version of our sha</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.mode" title="Permalink to this definition">¶</a></dt>
<dd>File Mode, compatible to stat module constants</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.path" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our path relative to the repository working tree root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.BaseIndexEntry.stage">
<tt class="descname">stage</tt><a class="headerlink" href="#git.index.typ.BaseIndexEntry.stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Stage of the entry, either:</p>
<blockquote>
<ul class="simple">
<li>0 = default stage</li>
<li>1 = stage before a merge or common ancestor entry in case of a 3 way merge</li>
<li>2 = stage of entries from the &#8216;left&#8217; side of the merge</li>
<li>3 = stage of entries from the right side of the merge</li>
</ul>
</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">For more information, see <a class="reference external" href="http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html">http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.index.typ.BaseIndexEntry.to_blob">
<tt class="descname">to_blob</tt><big>(</big><em>repo</em><big>)</big><a class="headerlink" href="#git.index.typ.BaseIndexEntry.to_blob" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Blob using the information of this index entry</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.index.typ.IndexEntry">
<em class="property">class </em><tt class="descclassname">git.index.typ.</tt><tt class="descname">IndexEntry</tt><a class="headerlink" href="#git.index.typ.IndexEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows convenient access to IndexEntry data without completely unpacking it.</p>
<p>Attributes usully accessed often are cached in the tuple whereas others are
unpacked on demand.</p>
<p>See the properties for a mapping between names and tuple indices.</p>
<dl class="attribute">
<dt id="git.index.typ.IndexEntry.ctime">
<tt class="descname">ctime</tt><a class="headerlink" href="#git.index.typ.IndexEntry.ctime" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Tuple(int_time_seconds_since_epoch, int_nano_seconds) of the
file&#8217;s creation time</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.dev">
<tt class="descname">dev</tt><a class="headerlink" href="#git.index.typ.IndexEntry.dev" title="Permalink to this definition">¶</a></dt>
<dd>Device ID</dd></dl>

<dl class="classmethod">
<dt id="git.index.typ.IndexEntry.from_base">
<em class="property">classmethod </em><tt class="descname">from_base</tt><big>(</big><em>base</em><big>)</big><a class="headerlink" href="#git.index.typ.IndexEntry.from_base" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Minimal entry as created from the given BaseIndexEntry instance.
Missing values will be set to null-like values</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>base</em> &#8211; Instance of type BaseIndexEntry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.index.typ.IndexEntry.from_blob">
<em class="property">classmethod </em><tt class="descname">from_blob</tt><big>(</big><em>blob</em>, <em>stage=0</em><big>)</big><a class="headerlink" href="#git.index.typ.IndexEntry.from_blob" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Minimal entry resembling the given blob object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.gid">
<tt class="descname">gid</tt><a class="headerlink" href="#git.index.typ.IndexEntry.gid" title="Permalink to this definition">¶</a></dt>
<dd>Group ID</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.inode">
<tt class="descname">inode</tt><a class="headerlink" href="#git.index.typ.IndexEntry.inode" title="Permalink to this definition">¶</a></dt>
<dd>Inode ID</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.mtime">
<tt class="descname">mtime</tt><a class="headerlink" href="#git.index.typ.IndexEntry.mtime" title="Permalink to this definition">¶</a></dt>
<dd>See ctime property, but returns modification time</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.size">
<tt class="descname">size</tt><a class="headerlink" href="#git.index.typ.IndexEntry.size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Uncompressed size of the blob</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.index.typ.IndexEntry.uid">
<tt class="descname">uid</tt><a class="headerlink" href="#git.index.typ.IndexEntry.uid" title="Permalink to this definition">¶</a></dt>
<dd>User ID</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.index.util">
<h2>Index.Util<a class="headerlink" href="#module-git.index.util" title="Permalink to this headline">¶</a></h2>
<p>Module containing index utilities</p>
<dl class="class">
<dt id="git.index.util.TemporaryFileSwap">
<em class="property">class </em><tt class="descclassname">git.index.util.</tt><tt class="descname">TemporaryFileSwap</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#git.index.util.TemporaryFileSwap" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class moving a file to a temporary location within the same directory
and moving it back on to where on object deletion.</p>
<dl class="attribute">
<dt id="git.index.util.TemporaryFileSwap.file_path">
<tt class="descname">file_path</tt><a class="headerlink" href="#git.index.util.TemporaryFileSwap.file_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.util.TemporaryFileSwap.tmp_file_path">
<tt class="descname">tmp_file_path</tt><a class="headerlink" href="#git.index.util.TemporaryFileSwap.tmp_file_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.index.util.post_clear_cache">
<tt class="descclassname">git.index.util.</tt><tt class="descname">post_clear_cache</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#git.index.util.post_clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for functions that alter the index using the git command. This would
invalidate our possibly existing entries dictionary which is why it must be
deleted to allow it to be lazily reread later.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This decorator will not be required once all functions are implemented
natively which in fact is possible, but probably not feasible performance wise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.index.util.default_index">
<tt class="descclassname">git.index.util.</tt><tt class="descname">default_index</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#git.index.util.default_index" title="Permalink to this definition">¶</a></dt>
<dd>Decorator assuring the wrapped method may only run if we are the default
repository index. This is as we rely on git commands that operate
on that index only.</dd></dl>

<dl class="function">
<dt id="git.index.util.git_working_dir">
<tt class="descclassname">git.index.util.</tt><tt class="descname">git_working_dir</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#git.index.util.git_working_dir" title="Permalink to this definition">¶</a></dt>
<dd>Decorator which changes the current working dir to the one of the git 
repository in order to assure relative paths are handled correctly</dd></dl>

</div>
<div class="section" id="module-git.cmd">
<h2>GitCmd<a class="headerlink" href="#module-git.cmd" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.cmd.Git">
<em class="property">class </em><tt class="descclassname">git.cmd.</tt><tt class="descname">Git</tt><big>(</big><em>working_dir=None</em><big>)</big><a class="headerlink" href="#git.cmd.Git" title="Permalink to this definition">¶</a></dt>
<dd><p>The Git class manages communication with the Git binary.</p>
<p>It provides a convenient interface to calling the Git binary, such as in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Git</span><span class="p">(</span> <span class="n">git_dir</span> <span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>                                       <span class="c"># calls &#39;git init&#39; program</span>
<span class="n">rval</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ls_files</span><span class="p">()</span>            <span class="c"># calls &#39;git ls-files&#39; program</span>
</pre></div>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Debugging</span></tt></dt>
<dd>Set the GIT_PYTHON_TRACE environment variable print each invocation 
of the command to stdout.
Set its value to &#8216;full&#8217; to see details about the returned values.</dd>
</dl>
<dl class="class">
<dt id="git.cmd.Git.AutoInterrupt">
<em class="property">class </em><tt class="descname">AutoInterrupt</tt><big>(</big><em>proc</em>, <em>args</em><big>)</big><a class="headerlink" href="#git.cmd.Git.AutoInterrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Kill/Interrupt the stored process instance once this instance goes out of scope. It is 
used to prevent processes piling up in case iterators stop reading.
Besides all attributes are wired through to the contained process object.</p>
<p>The wait method was overridden to perform automatic status code checking
and possibly raise.</p>
<dl class="attribute">
<dt id="git.cmd.Git.AutoInterrupt.args">
<tt class="descname">args</tt><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.AutoInterrupt.proc">
<tt class="descname">proc</tt><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.proc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.AutoInterrupt.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for the process and return its status code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises GitCommandError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the return status is not 0</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.cmd.Git.CatFileContentStream">
<em class="property">class </em><tt class="descclassname">Git.</tt><tt class="descname">CatFileContentStream</tt><big>(</big><em>size</em>, <em>stream</em><big>)</big><a class="headerlink" href="#git.cmd.Git.CatFileContentStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Object representing a sized read-only stream returning the contents of 
an object.
It behaves like a stream, but counts the data read and simulates an empty 
stream once our sized content region is empty.
If not all data is read to the end of the objects&#8217;s lifetime, we read the 
rest to assure the underlying stream continues to work</p>
<dl class="method">
<dt id="git.cmd.Git.CatFileContentStream.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#git.cmd.Git.CatFileContentStream.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.CatFileContentStream.read">
<tt class="descname">read</tt><big>(</big><em>size=-1</em><big>)</big><a class="headerlink" href="#git.cmd.Git.CatFileContentStream.read" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.CatFileContentStream.readline">
<tt class="descname">readline</tt><big>(</big><em>size=-1</em><big>)</big><a class="headerlink" href="#git.cmd.Git.CatFileContentStream.readline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.CatFileContentStream.readlines">
<tt class="descname">readlines</tt><big>(</big><em>size=-1</em><big>)</big><a class="headerlink" href="#git.cmd.Git.CatFileContentStream.readlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.cat_file_all">
<tt class="descclassname">Git.</tt><tt class="descname">cat_file_all</tt><a class="headerlink" href="#git.cmd.Git.cat_file_all" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.cat_file_header">
<tt class="descclassname">Git.</tt><tt class="descname">cat_file_header</tt><a class="headerlink" href="#git.cmd.Git.cat_file_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.clear_cache">
<tt class="descclassname">Git.</tt><tt class="descname">clear_cache</tt><big>(</big><big>)</big><a class="headerlink" href="#git.cmd.Git.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all kinds of internal caches to release resources.</p>
<p>Currently persistent commands will be interrupted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.execute">
<tt class="descclassname">Git.</tt><tt class="descname">execute</tt><big>(</big><em>command</em>, <em>istream=None</em>, <em>with_keep_cwd=False</em>, <em>with_extended_output=False</em>, <em>with_exceptions=True</em>, <em>as_process=False</em>, <em>output_stream=None</em>, <em>**subprocess_kwargs</em><big>)</big><a class="headerlink" href="#git.cmd.Git.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles executing the command on the shell and consumes and returns
the returned information (stdout)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>command</em> &#8211; The command argument list to execute.
It should be a string, or a sequence of program arguments. The
program to execute is the first item in the args sequence or string.</li>
<li><em>istream</em> &#8211; Standard input filehandle passed to subprocess.Popen.</li>
<li><em>with_keep_cwd</em> &#8211; Whether to use the current working directory from os.getcwd().
The cmd otherwise uses its own working_dir that it has been initialized
with if possible.</li>
<li><em>with_extended_output</em> &#8211; Whether to return a (status, stdout, stderr) tuple.</li>
<li><em>with_exceptions</em> &#8211; Whether to raise an exception when git returns a non-zero status.</li>
<li><em>as_process</em> &#8211; Whether to return the created process instance directly from which 
streams can be read on demand. This will render with_extended_output and 
with_exceptions ineffective - the caller will have 
to deal with the details himself.
It is important to note that the process will be placed into an AutoInterrupt
wrapper that will interrupt the process once it goes out of scope. If you 
use the command in iterators, you should pass the whole process instance 
instead of a single stream.</li>
<li><em>output_stream</em> &#8211; If set to a file-like object, data produced by the git command will be 
output to the given stream directly.
This feature only has any effect if as_process is False. Processes will
always be created with a pipe due to issues with subprocess.
This merely is a workaround as data will be copied from the 
output pipe to the given output stream directly.</li>
<li><em>subprocess_kwargs</em> &#8211; Keyword arguments to be passed to subprocess.Popen. Please note that 
some of the valid kwargs are already set by this method, the ones you 
specify may not be the same ones.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first simple">
<li>str(output) if extended_output = False (Default)</li>
<li>tuple(int(status), str(stdout), str(stderr)) if extended_output = True</li>
</ul>
<p>if ouput_stream is True, the stdout value will be your output stream:
* output_stream if extended_output = False
* tuple(int(status), output_stream, str(stderr)) if extended_output = True</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises GitCommandError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">If you add additional keyword arguments to the signature of this method, 
you must update the execute_kwargs tuple housed in this module.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.get_object_data">
<tt class="descclassname">Git.</tt><tt class="descname">get_object_data</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#git.cmd.Git.get_object_data" title="Permalink to this definition">¶</a></dt>
<dd>As get_object_header, but returns object data as well
:return: (hexsha, type_string, size_as_int,data_string)
:note: not threadsafe</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.get_object_header">
<tt class="descclassname">Git.</tt><tt class="descname">get_object_header</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#git.cmd.Git.get_object_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this method to quickly examine the type and size of the object behind 
the given ref.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">The method will only suffer from the costs of command invocation 
once and reuses the command in subsequent calls.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">(hexsha, type_string, size_as_int)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.stream_object_data">
<tt class="descclassname">Git.</tt><tt class="descname">stream_object_data</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#git.cmd.Git.stream_object_data" title="Permalink to this definition">¶</a></dt>
<dd><p>As get_object_header, but returns the data as a stream
:return: (hexsha, type_string, size_as_int, stream)
:note: This method is not threadsafe, you need one independent  Command instance</p>
<blockquote>
per thread to be safe !</blockquote>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.transform_kwargs">
<tt class="descclassname">Git.</tt><tt class="descname">transform_kwargs</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#git.cmd.Git.transform_kwargs" title="Permalink to this definition">¶</a></dt>
<dd>Transforms Python style kwargs into git command line options.</dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.working_dir">
<tt class="descclassname">Git.</tt><tt class="descname">working_dir</tt><a class="headerlink" href="#git.cmd.Git.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Git directory we are working on</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.config">
<h2>Config<a class="headerlink" href="#module-git.config" title="Permalink to this headline">¶</a></h2>
<p>Module containing module parser implementation able to properly read and write
configuration files</p>
<dl class="attribute">
<dt id="git.config.GitConfigParser">
<tt class="descclassname">git.config.</tt><tt class="descname">GitConfigParser</tt><a class="headerlink" href="#git.config.GitConfigParser" title="Permalink to this definition">¶</a></dt>
<dd>alias of <tt class="xref docutils literal"><span class="pre">write</span></tt></dd></dl>

</div>
<div class="section" id="module-git.diff">
<h2>Diff<a class="headerlink" href="#module-git.diff" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.diff.Diffable">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">Diffable</tt><a class="headerlink" href="#git.diff.Diffable" title="Permalink to this definition">¶</a></dt>
<dd><p>Common interface for all object that can be diffed against another object of compatible type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Subclasses require a repo member as it is the case for Object instances, for practical 
reasons we do not derive from Object.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="git.diff.Diffable.Index">
<em class="property">class </em><tt class="descname">Index</tt><a class="headerlink" href="#git.diff.Diffable.Index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.diff.Diffable.diff">
<tt class="descclassname">Diffable.</tt><tt class="descname">diff</tt><big>(</big><em>other=&lt;class 'git.diff.Index'&gt;</em>, <em>paths=None</em>, <em>create_patch=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.diff.Diffable.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates diffs between two items being trees, trees and index or an 
index and the working tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>other</em> &#8211; Is the item to compare us with. 
If None, we will be compared to the working tree.
If Treeish, it will be compared against the respective tree
If Index ( type ), it will be compared against the index.
It defaults to Index to assure the method will not by-default fail
on bare repositories.</li>
<li><em>paths</em> &#8211; is a list of paths or a single path to limit the diff to.
It will only include at least one of the givne path or paths.</li>
<li><em>create_patch</em> &#8211; If True, the returned Diff contains a detailed patch that if applied
makes the self to other. Patches are somwhat costly as blobs have to be read
and diffed.</li>
<li><em>kwargs</em> &#8211; Additional arguments passed to git-diff, such as 
R=True to swap both sides of the diff.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">git.DiffIndex</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">Rename detection will only work if create_patch is True.</p>
<p class="last">On a bare repository, &#8216;other&#8217; needs to be provided as Index or as 
as Tree/Commit, or a git command error will occour</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.diff.DiffIndex">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">DiffIndex</tt><a class="headerlink" href="#git.diff.DiffIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Index for diffs, allowing a list of Diffs to be queried by 
the diff properties.</p>
<p>The class improves the diff handling convenience</p>
<dl class="method">
<dt id="git.diff.DiffIndex.iter_change_type">
<tt class="descname">iter_change_type</tt><big>(</big><em>change_type</em><big>)</big><a class="headerlink" href="#git.diff.DiffIndex.iter_change_type" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">iterator yieling Diff instances that match the given change_type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>change_type</em> &#8211; <p>Member of DiffIndex.change_type, namely:</p>
<ul class="simple">
<li>&#8216;A&#8217; for added paths</li>
<li>&#8216;D&#8217; for deleted paths</li>
<li>&#8216;R&#8217; for renamed paths</li>
<li>&#8216;M&#8217; for paths with modified data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.diff.Diff">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">Diff</tt><big>(</big><em>repo</em>, <em>a_path</em>, <em>b_path</em>, <em>a_blob_id</em>, <em>b_blob_id</em>, <em>a_mode</em>, <em>b_mode</em>, <em>new_file</em>, <em>deleted_file</em>, <em>rename_from</em>, <em>rename_to</em>, <em>diff</em><big>)</big><a class="headerlink" href="#git.diff.Diff" title="Permalink to this definition">¶</a></dt>
<dd><p>A Diff contains diff information between two Trees.</p>
<p>It contains two sides a and b of the diff, members are prefixed with 
&#8220;a&#8221; and &#8220;b&#8221; respectively to inidcate that.</p>
<p>Diffs keep information about the changed blob objects, the file mode, renames, 
deletions and new files.</p>
<p>There are a few cases where None has to be expected as member variable value:</p>
<p><tt class="docutils literal"><span class="pre">New</span> <span class="pre">File</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a_mode</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">a_blob</span> <span class="ow">is</span> <span class="bp">None</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Deleted</span> <span class="pre">File</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b_mode</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">b_blob</span> <span class="ow">is</span> <span class="bp">None</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Working</span> <span class="pre">Tree</span> <span class="pre">Blobs</span></tt></p>
<blockquote>
When comparing to working trees, the working tree blob will have a null hexsha
as a corresponding object does not yet exist. The mode will be null as well.
But the path will be available though. 
If it is listed in a diff the working tree version of the file must 
be different to the version in the index or tree, and hence has been modified.</blockquote>
<dl class="attribute">
<dt id="git.diff.Diff.a_blob">
<tt class="descname">a_blob</tt><a class="headerlink" href="#git.diff.Diff.a_blob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.a_mode">
<tt class="descname">a_mode</tt><a class="headerlink" href="#git.diff.Diff.a_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.b_blob">
<tt class="descname">b_blob</tt><a class="headerlink" href="#git.diff.Diff.b_blob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.b_mode">
<tt class="descname">b_mode</tt><a class="headerlink" href="#git.diff.Diff.b_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.deleted_file">
<tt class="descname">deleted_file</tt><a class="headerlink" href="#git.diff.Diff.deleted_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.diff">
<tt class="descname">diff</tt><a class="headerlink" href="#git.diff.Diff.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.new_file">
<tt class="descname">new_file</tt><a class="headerlink" href="#git.diff.Diff.new_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.rename_from">
<tt class="descname">rename_from</tt><a class="headerlink" href="#git.diff.Diff.rename_from" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.rename_to">
<tt class="descname">rename_to</tt><a class="headerlink" href="#git.diff.Diff.rename_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.renamed">
<tt class="descname">renamed</tt><a class="headerlink" href="#git.diff.Diff.renamed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the blob of our diff has been renamed</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.errors">
<h2>Errors<a class="headerlink" href="#module-git.errors" title="Permalink to this headline">¶</a></h2>
<p>Module containing all exceptions thrown througout the git package,</p>
<dl class="exception">
<dt id="git.errors.GitCommandError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">GitCommandError</tt><big>(</big><em>command</em>, <em>status</em>, <em>stderr=None</em><big>)</big><a class="headerlink" href="#git.errors.GitCommandError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if execution of the git command fails with non-zero status code.</dd></dl>

<dl class="exception">
<dt id="git.errors.InvalidGitRepositoryError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">InvalidGitRepositoryError</tt><a class="headerlink" href="#git.errors.InvalidGitRepositoryError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if the given repository appears to have an invalid format.</dd></dl>

<dl class="exception">
<dt id="git.errors.NoSuchPathError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">NoSuchPathError</tt><a class="headerlink" href="#git.errors.NoSuchPathError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if a path could not be access by the system.</dd></dl>

</div>
<div class="section" id="module-git.refs">
<h2>Refs<a class="headerlink" href="#module-git.refs" title="Permalink to this headline">¶</a></h2>
<p>Module containing all ref based objects</p>
<dl class="class">
<dt id="git.refs.SymbolicReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">SymbolicReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a special case of a reference such that this reference is symbolic.
It does not point to a specific commit, but to another Head, which itself 
specifies a commit.</p>
<p>A typical example for a symbolic reference is HEAD.</p>
<dl class="attribute">
<dt id="git.refs.SymbolicReference.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.refs.SymbolicReference.commit" title="Permalink to this definition">¶</a></dt>
<dd>Query or set commits directly</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>reference='HEAD'</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new symbolic reference, hence a reference pointing to another reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; Repository to create the reference in</li>
<li><em>path</em> &#8211; full path at which the new symbolic reference is supposed to be 
created at, i.e. &#8220;NEW_HEAD&#8221; or &#8220;symrefs/my_new_symref&#8221;</li>
<li><em>reference</em> &#8211; The reference to which the new symbolic reference should point to</li>
<li><em>force</em> &#8211; if True, force creation even if a symbolic reference with that name already exists.
Raise OSError otherwise</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Newly created symbolic Reference</p>
</td>
</tr>
<tr class="field"><th class="field-name">Raises OSError:</th><td class="field-body"><p class="first">If a (Symbolic)Reference with the same name but different contents
already exists.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">This does not alter the current HEAD, index or Working Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the reference at the given path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>repo</em> &#8211; Repository to delete the reference from</li>
<li><em>path</em> &#8211; Short or full path pointing to the reference, i.e. refs/myreference
or just &#8220;myreference&#8221;, hence &#8216;refs/&#8217; is implied.
Alternatively the symbolic reference to be deleted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.dereference_recursive">
<em class="property">classmethod </em><tt class="descname">dereference_recursive</tt><big>(</big><em>repo</em>, <em>ref_path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.dereference_recursive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">hexsha stored in the reference at the given ref_path, recursively dereferencing all
intermediate references as required</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>repo</em> &#8211; the repository containing the reference at ref_path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.from_path">
<em class="property">classmethod </em><tt class="descname">from_path</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.from_path" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Instance of type Reference, Head, or Tag
depending on the given path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.is_detached">
<tt class="descname">is_detached</tt><a class="headerlink" href="#git.refs.SymbolicReference.is_detached" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if we are a detached reference, hence we point to a specific commit
instead to another reference</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.refs.SymbolicReference.is_valid">
<tt class="descname">is_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the reference is valid, hence it can be read and points to 
a valid object or reference.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>common_path=None</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all refs in the repository</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; is the Repo</li>
<li><em>common_path</em> &#8211; Optional keyword argument to the path which is to be shared by all
returned Ref objects.
Defaults to class specific portion if None assuring that only 
refs suitable for the actual class are returned.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">git.SymbolicReference[], each of them is guaranteed to be a symbolic
ref which is not detached.</p>
<p class="last">List is lexigraphically sorted
The returned objects represent actual subclasses, such as Head or TagReference</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.refs.SymbolicReference.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">In case of symbolic references, the shortest assumable name 
is the path itself.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.refs.SymbolicReference.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.ref">
<tt class="descname">ref</tt><a class="headerlink" href="#git.refs.SymbolicReference.ref" title="Permalink to this definition">¶</a></dt>
<dd>Returns the Reference we point to</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.reference">
<tt class="descname">reference</tt><a class="headerlink" href="#git.refs.SymbolicReference.reference" title="Permalink to this definition">¶</a></dt>
<dd>Returns the Reference we point to</dd></dl>

<dl class="method">
<dt id="git.refs.SymbolicReference.rename">
<tt class="descname">rename</tt><big>(</big><em>new_path</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename self to a new path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>new_path</em> &#8211; Either a simple name or a full path, i.e. new_name or features/new_name.
The prefix refs/ is implied for references and will be set as needed.
In case this is a symbolic ref, there is no implied prefix</li>
<li><em>force</em> &#8211; If True, the rename will succeed even if a head with the target name
already exists. It will be overwritten in that case</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self</p>
</td>
</tr>
<tr class="field"><th class="field-name">Raises OSError:</th><td class="field-body"><p class="first last">In case a file at path but a different contents already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.refs.SymbolicReference.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.to_full_path">
<em class="property">classmethod </em><tt class="descname">to_full_path</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.to_full_path" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">string with a full path name which can be used to initialize 
a Reference instance, for instance by using <tt class="docutils literal"><span class="pre">Reference.from_path</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.Reference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">Reference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.Reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a named reference to any object. Subclasses may apply restrictions though, 
i.e. Heads can only point to commits.</p>
<dl class="classmethod">
<dt id="git.refs.Reference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.Reference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>repo</em> &#8211; Repository to create the reference in</li>
<li><em>path</em> &#8211; The relative path of the reference, i.e. &#8216;new_branch&#8217; or 
feature/feature1. The path prefix &#8216;refs/&#8217; is implied if not 
given explicitly</li>
<li><em>commit</em> &#8211; Commit to which the new reference should point, defaults to the 
current HEAD</li>
<li><em>force</em> &#8211; if True, force creation even if a reference with that  name already exists.
Raise OSError otherwise</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Newly created Reference</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">This does not alter the current HEAD, index or Working Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Reference.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>common_path=None</em><big>)</big><a class="headerlink" href="#git.refs.Reference.iter_items" title="Permalink to this definition">¶</a></dt>
<dd>Equivalent to SymbolicReference.iter_items, but will return non-detached
references as well.</dd></dl>

<dl class="attribute">
<dt id="git.refs.Reference.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.refs.Reference.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">(shortest) Name of this reference - it may contain path components</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.Reference.object">
<tt class="descname">object</tt><a class="headerlink" href="#git.refs.Reference.object" title="Permalink to this definition">¶</a></dt>
<dd>Return the object our ref currently refers to</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.HEAD">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">HEAD</tt><big>(</big><em>repo</em>, <em>path='HEAD'</em><big>)</big><a class="headerlink" href="#git.refs.HEAD" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of a Symbolic Reference as it represents the repository&#8217;s 
HEAD reference.</p>
<dl class="method">
<dt id="git.refs.HEAD.reset">
<tt class="descname">reset</tt><big>(</big><em>commit='HEAD'</em>, <em>index=True</em>, <em>working_tree=False</em>, <em>paths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.HEAD.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset our HEAD to the given commit optionally synchronizing 
the index and working tree. The reference we refer to will be set to 
commit as well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>commit</em> &#8211; Commit object, Reference Object or string identifying a revision we 
should reset HEAD to.</li>
<li><em>index</em> &#8211; If True, the index will be set to match the given commit. Otherwise
it will not be touched.</li>
<li><em>working_tree</em> &#8211; If True, the working tree will be forcefully adjusted to match the given
commit, possibly overwriting uncommitted changes without warning.
If working_tree is True, index must be true as well</li>
<li><em>paths</em> &#8211; Single path or list of paths relative to the git root directory
that are to be reset. This allows to partially reset individual files.</li>
<li><em>kwargs</em> &#8211; Additional arguments passed to git-reset.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.Head">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">Head</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.Head" title="Permalink to this definition">¶</a></dt>
<dd><p>A Head is a named reference to a Commit. Every Head instance contains a name
and a Commit object.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span> <span class="o">=</span> <span class="n">Repo</span><span class="p">(</span><span class="s">&quot;/path/to/repo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;master&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">commit</span>
<span class="go">&lt;git.Commit &quot;1c09f116cbc2cb4100fb6935bb162daa4723f455&quot;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">commit</span><span class="o">.</span><span class="n">hexsha</span>
<span class="go">&#39;1c09f116cbc2cb4100fb6935bb162daa4723f455&#39;</span>
</pre></div>
</div>
<dl class="method">
<dt id="git.refs.Head.checkout">
<tt class="descname">checkout</tt><big>(</big><em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.checkout" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkout this head by setting the HEAD to this reference, by updating the index
to reflect the tree we point to and by updating the working tree to reflect 
the latest index.</p>
<p>The command will fail if changed working tree files would be overwritten.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>force</em> &#8211; If True, changes to the index and the working tree will be discarded.
If False, GitCommandError will be raised in that situation.</li>
<li><em>kwargs</em> &#8211; Additional keyword arguments to be passed to git checkout, i.e.
b=&#8217;new_branch&#8217; to create a new branch at the given spot.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The active branch after the checkout operation, usually self unless
a new branch has been created.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">By default it is only allowed to checkout heads - everything else
will leave the HEAD detached which is allowed and possible, but remains
a special state that some tools might not be able to handle.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Head.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new head.
:param repo: Repository to create the head in 
:param path:</p>
<blockquote>
The name or path of the head, i.e. &#8216;new_branch&#8217; or 
feature/feature1. The prefix refs/heads is implied.</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>commit</em> &#8211; Commit to which the new head should point, defaults to the 
current HEAD</li>
<li><em>force</em> &#8211; if True, force creation even if branch with that  name already exists.</li>
<li><em>kwargs</em> &#8211; Additional keyword arguments to be passed to git-branch, i.e.
track, no-track, l</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Newly created Head</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">This does not alter the current HEAD, index or Working Tree</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Head.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*heads</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given heads
:param force:</p>
<blockquote>
If True, the heads will be deleted even if they are not yet merged into
the main development stream.
Default False</blockquote>
</dd></dl>

<dl class="method">
<dt id="git.refs.Head.rename">
<tt class="descname">rename</tt><big>(</big><em>new_path</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.Head.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename self to a new path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>new_path</em> &#8211; Either a simple name or a path, i.e. new_name or features/new_name.
The prefix refs/heads is implied</li>
<li><em>force</em> &#8211; If True, the rename will succeed even if a head with the target name
already exists.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">respects the ref log as git commands are used</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.TagReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">TagReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.TagReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a lightweight tag reference which either points to a commit 
,a tag object or any other object. In the latter case additional information, 
like the signature or the tag-creator, is available.</p>
<p>This tag object will always point to a commit object, but may carray additional
information in a tag object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tagref</span> <span class="o">=</span> <span class="n">TagReference</span><span class="o">.</span><span class="n">list_items</span><span class="p">(</span><span class="n">repo</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>
<span class="k">print</span> <span class="n">tagref</span><span class="o">.</span><span class="n">commit</span><span class="o">.</span><span class="n">message</span>
<span class="k">if</span> <span class="n">tagref</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
       <span class="k">print</span> <span class="n">tagref</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">message</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.refs.TagReference.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.refs.TagReference.commit" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Commit object the tag ref points to</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.TagReference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>ref='HEAD'</em>, <em>message=None</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.TagReference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new tag reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>path</em> &#8211; The name of the tag, i.e. 1.0 or releases/1.0. 
The prefix refs/tags is implied</li>
<li><em>ref</em> &#8211; A reference to the object you want to tag. It can be a commit, tree or 
blob.</li>
<li><em>message</em> &#8211; <p>If not None, the message will be used in your tag object. This will also 
create an additional tag object that allows to obtain that information, i.e.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tagref</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">message</span>
</pre></div>
</div>
</li>
<li><em>force</em> &#8211; If True, to force creation of a tag even though that tag already exists.</li>
<li><em>kwargs</em> &#8211; Additional keyword arguments to be passed to git-tag</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A new TagReference</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.TagReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*tags</em><big>)</big><a class="headerlink" href="#git.refs.TagReference.delete" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given existing tag or tags</dd></dl>

<dl class="attribute">
<dt id="git.refs.TagReference.object">
<tt class="descname">object</tt><a class="headerlink" href="#git.refs.TagReference.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The object our ref currently refers to. Refs can be cached, they will 
always point to the actual object as it gets re-created on each query</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.TagReference.tag">
<tt class="descname">tag</tt><a class="headerlink" href="#git.refs.TagReference.tag" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Tag object this tag ref points to or None in case 
we are a light weight tag</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.RemoteReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">RemoteReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.RemoteReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a reference pointing to a remote head.</p>
<dl class="classmethod">
<dt id="git.refs.RemoteReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*refs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.RemoteReference.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given remote references.
:note:</p>
<blockquote>
kwargs are given for compatability with the base class method as we 
should not narrow the signature.</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.RemoteReference.remote_head">
<tt class="descname">remote_head</tt><a class="headerlink" href="#git.refs.RemoteReference.remote_head" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Name of the remote head itself, i.e. master.</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">The returned name is usually not qualified enough to uniquely identify
a branch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.RemoteReference.remote_name">
<tt class="descname">remote_name</tt><a class="headerlink" href="#git.refs.RemoteReference.remote_name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Name of the remote we are a reference of, such as &#8216;origin&#8217; for a reference
named &#8216;origin/master&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="git.refs.Tag">
<tt class="descclassname">git.refs.</tt><tt class="descname">Tag</tt><a class="headerlink" href="#git.refs.Tag" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="git.refs.TagReference" class="reference internal" href="#git.refs.TagReference"><tt class="xref docutils literal"><span class="pre">TagReference</span></tt></a></dd></dl>

</div>
<div class="section" id="module-git.remote">
<h2>Remote<a class="headerlink" href="#module-git.remote" title="Permalink to this headline">¶</a></h2>
<p>Module implementing a remote object allowing easy access to git remotes</p>
<dl class="class">
<dt id="git.remote.RemoteProgress">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">RemoteProgress</tt><a class="headerlink" href="#git.remote.RemoteProgress" title="Permalink to this definition">¶</a></dt>
<dd><p>Handler providing an interface to parse progress information emitted by git-push
and git-fetch and to dispatch callbacks allowing subclasses to react to the progress.</p>
<dl class="method">
<dt id="git.remote.RemoteProgress.line_dropped">
<tt class="descname">line_dropped</tt><big>(</big><em>line</em><big>)</big><a class="headerlink" href="#git.remote.RemoteProgress.line_dropped" title="Permalink to this definition">¶</a></dt>
<dd>Called whenever a line could not be understood and was therefore dropped.</dd></dl>

<dl class="method">
<dt id="git.remote.RemoteProgress.update">
<tt class="descname">update</tt><big>(</big><em>op_code</em>, <em>cur_count</em>, <em>max_count=None</em>, <em>message=''</em><big>)</big><a class="headerlink" href="#git.remote.RemoteProgress.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the progress changes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>op_code</em> &#8211; <p>Integer allowing to be compared against Operation IDs and stage IDs.</p>
<p>Stage IDs are BEGIN and END. BEGIN will only be set once for each Operation 
ID as well as END. It may be that BEGIN and END are set at once in case only
one progress message was emitted due to the speed of the operation.
Between BEGIN and END, none of these flags will be set</p>
<p>Operation IDs are all held within the OP_MASK. Only one Operation ID will 
be active per call.</p>
</li>
<li><em>cur_count</em> &#8211; Current absolute count of items</li>
<li><em>max_count</em> &#8211; The maximum count of items we expect. It may be None in case there is 
no maximum number of items or if it is (yet) unknown.</li>
<li><em>message</em> &#8211; In case of the &#8216;WRITING&#8217; operation, it contains the amount of bytes
transferred. It may possibly be used for other purposes as well.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>You may read the contents of the current line in self._cur_line</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.PushInfo">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">PushInfo</tt><big>(</big><em>flags</em>, <em>local_ref</em>, <em>remote_ref_string</em>, <em>remote</em>, <em>old_commit=None</em>, <em>summary=''</em><big>)</big><a class="headerlink" href="#git.remote.PushInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Carries information about the result of a push operation of a single head:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">push</span><span class="p">()[</span><span class="mf">0</span><span class="p">]</span>
<span class="n">info</span><span class="o">.</span><span class="n">flags</span>                      <span class="c"># bitflags providing more information about the result</span>
<span class="n">info</span><span class="o">.</span><span class="n">local_ref</span>          <span class="c"># Reference pointing to the local reference that was pushed</span>
                                        <span class="c"># It is None if the ref was deleted.</span>
<span class="n">info</span><span class="o">.</span><span class="n">remote_ref_string</span> <span class="c"># path to the remote reference located on the remote side</span>
<span class="n">info</span><span class="o">.</span><span class="n">remote_ref</span> <span class="c"># Remote Reference on the local side corresponding to </span>
                                <span class="c"># the remote_ref_string. It can be a TagReference as well.</span>
<span class="n">info</span><span class="o">.</span><span class="n">old_commit</span> <span class="c"># commit at which the remote_ref was standing before we pushed</span>
                                <span class="c"># it to local_ref.commit. Will be None if an error was indicated</span>
<span class="n">info</span><span class="o">.</span><span class="n">summary</span>    <span class="c"># summary line providing human readable english text about the push</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.remote.PushInfo.flags">
<tt class="descname">flags</tt><a class="headerlink" href="#git.remote.PushInfo.flags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.local_ref">
<tt class="descname">local_ref</tt><a class="headerlink" href="#git.remote.PushInfo.local_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.old_commit">
<tt class="descname">old_commit</tt><a class="headerlink" href="#git.remote.PushInfo.old_commit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.remote_ref">
<tt class="descname">remote_ref</tt><a class="headerlink" href="#git.remote.PushInfo.remote_ref" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Remote Reference or TagReference in the local repository corresponding 
to the remote_ref_string kept in this instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.remote_ref_string">
<tt class="descname">remote_ref_string</tt><a class="headerlink" href="#git.remote.PushInfo.remote_ref_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.summary">
<tt class="descname">summary</tt><a class="headerlink" href="#git.remote.PushInfo.summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.FetchInfo">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">FetchInfo</tt><big>(</big><em>ref</em>, <em>flags</em>, <em>note=''</em>, <em>old_commit=None</em><big>)</big><a class="headerlink" href="#git.remote.FetchInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Carries information about the results of a fetch operation of a single head:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">fetch</span><span class="p">()[</span><span class="mf">0</span><span class="p">]</span>
<span class="n">info</span><span class="o">.</span><span class="n">ref</span>                       <span class="c"># Symbolic Reference or RemoteReference to the changed </span>
                                       <span class="c"># remote head or FETCH_HEAD</span>
<span class="n">info</span><span class="o">.</span><span class="n">flags</span>                     <span class="c"># additional flags to be &amp; with enumeration members, </span>
                                       <span class="c"># i.e. info.flags &amp; info.REJECTED </span>
                                       <span class="c"># is 0 if ref is SymbolicReference</span>
<span class="n">info</span><span class="o">.</span><span class="n">note</span>                      <span class="c"># additional notes given by git-fetch intended for the user</span>
<span class="n">info</span><span class="o">.</span><span class="n">old_commit</span>        <span class="c"># if info.flags &amp; info.FORCED_UPDATE|info.FAST_FORWARD, </span>
                                       <span class="c"># field is set to the previous location of ref, otherwise None</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.remote.FetchInfo.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.remote.FetchInfo.commit" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Commit of our remote ref</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.flags">
<tt class="descname">flags</tt><a class="headerlink" href="#git.remote.FetchInfo.flags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.remote.FetchInfo.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Name of our remote ref</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.note">
<tt class="descname">note</tt><a class="headerlink" href="#git.remote.FetchInfo.note" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.old_commit">
<tt class="descname">old_commit</tt><a class="headerlink" href="#git.remote.FetchInfo.old_commit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.ref">
<tt class="descname">ref</tt><a class="headerlink" href="#git.remote.FetchInfo.ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.Remote">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">Remote</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides easy read and write access to a git remote.</p>
<p>Everything not part of this interface is considered an option for the current 
remote, allowing constructs like remote.pushurl to query the pushurl.</p>
<p>NOTE: When querying configuration, the configuration accessor will be cached
to speed up subsequent accesses.</p>
<dl class="classmethod">
<dt id="git.remote.Remote.add">
<em class="property">classmethod </em><tt class="descname">add</tt><big>(</big><em>repo</em>, <em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote to the given repository
:param repo: Repository instance that is to receive the new remote
:param name: Desired name of the remote
:param url: URL which corresponds to the remote&#8217;s name
:param kwargs:</p>
<blockquote>
Additional arguments to be passed to the git-remote add command</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">New Remote instance</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises GitCommandError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">in case an origin with that name already exists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.config_reader">
<tt class="descname">config_reader</tt><a class="headerlink" href="#git.remote.Remote.config_reader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">GitConfigParser compatible object able to read options for only our remote.
Hence you may simple type config.get(&#8220;pushurl&#8221;) to obtain the information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.config_writer">
<tt class="descname">config_writer</tt><a class="headerlink" href="#git.remote.Remote.config_writer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">GitConfigParser compatible object able to write options for this remote.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">You can only own one writer at a time - delete it to release the 
configuration file and make it useable by others.</p>
<p class="last">To assure consistent results, you should only query options through the 
writer. Once you are done writing, you are free to use the config reader 
once again.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote to the given repository
:param repo: Repository instance that is to receive the new remote
:param name: Desired name of the remote
:param url: URL which corresponds to the remote&#8217;s name
:param kwargs:</p>
<blockquote>
Additional arguments to be passed to the git-remote add command</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">New Remote instance</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises GitCommandError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">in case an origin with that name already exists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.fetch">
<tt class="descname">fetch</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch the latest changes for this remote</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>refspec</em> &#8211; <p>A &#8220;refspec&#8221; is used by fetch and push to describe the mapping 
between remote ref and local ref. They are combined with a colon in 
the format &lt;src&gt;:&lt;dst&gt;, preceded by an optional plus sign, +. 
For example: git fetch $URL refs/heads/master:refs/heads/origin means 
&#8220;grab the master branch head from the $URL and store it as my origin 
branch head&#8221;. And git push $URL refs/heads/master:refs/heads/to-upstream 
means &#8220;publish my master branch head as to-upstream branch at $URL&#8221;. 
See also git-push(1).</p>
<p>Taken from the git manual</p>
</li>
<li><em>progress</em> &#8211; See &#8216;push&#8217; method</li>
<li><em>kwargs</em> &#8211; Additional arguments to be passed to git-fetch</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">IterableList(FetchInfo, ...) list of FetchInfo instances providing detailed 
information about the fetch results</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">As fetch does not provide progress information to non-ttys, we cannot make 
it available here unfortunately as in the &#8216;push&#8217; method.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em><big>)</big><a class="headerlink" href="#git.remote.Remote.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator yielding Remote objects of the given repository</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.remote.Remote.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.remote.Remote.pull">
<tt class="descname">pull</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.pull" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull changes from the given branch, being the same as a fetch followed 
by a merge of branch with your local branch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>refspec</em> &#8211; see &#8216;fetch&#8217; method</li>
<li><em>progress</em> &#8211; see &#8216;push&#8217; method</li>
<li><em>kwargs</em> &#8211; Additional arguments to be passed to git-pull</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Please see &#8216;fetch&#8217; method</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.push">
<tt class="descname">push</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push changes from source branch in refspec to target branch in refspec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>refspec</em> &#8211; see &#8216;fetch&#8217; method</li>
<li><em>progress</em> &#8211; Instance of type RemoteProgress allowing the caller to receive 
progress information until the method returns.
If None, progress information will be discarded</li>
<li><em>kwargs</em> &#8211; Additional arguments to be passed to git-push</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">IterableList(PushInfo, ...) iterable list of PushInfo instances, each 
one informing about an individual head which had been updated on the remote 
side.
If the push contains rejected heads, these will have the PushInfo.ERROR bit set
in their flags.
If the operation fails completely, the length of the returned IterableList will
be null.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.refs">
<tt class="descname">refs</tt><a class="headerlink" href="#git.remote.Remote.refs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">IterableList of RemoteReference objects. It is prefixed, allowing 
you to omit the remote path portion, i.e.:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">remote</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">master</span> <span class="c"># yields RemoteReference(&#39;/refs/remotes/origin/master&#39;)</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.remove">
<em class="property">classmethod </em><tt class="descname">remove</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.remove" title="Permalink to this definition">¶</a></dt>
<dd>Remove the remote with the given name</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.rename">
<tt class="descname">rename</tt><big>(</big><em>new_name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.rename" title="Permalink to this definition">¶</a></dt>
<dd>Rename self to the given new_name
:return: self</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.remote.Remote.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.rm">
<em class="property">classmethod </em><tt class="descname">rm</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.rm" title="Permalink to this definition">¶</a></dt>
<dd>Remove the remote with the given name</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.stale_refs">
<tt class="descname">stale_refs</tt><a class="headerlink" href="#git.remote.Remote.stale_refs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">IterableList RemoteReference objects that do not have a corresponding 
head in the remote reference anymore as they have been deleted on the 
remote side, but are still available locally.</p>
<p class="last">The IterableList is prefixed, hence the &#8216;origin&#8217; must be omitted. See
&#8216;refs&#8217; property for an example.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.update">
<tt class="descname">update</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch all changes for this remote, including new branches which will 
be forced in ( in case your local remote branch is not part the new remote branches
ancestry anymore ).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; Additional arguments passed to git-remote update</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.repo.base">
<h2>Repo.Base<a class="headerlink" href="#module-git.repo.base" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.repo.base.Repo">
<em class="property">class </em><tt class="descclassname">git.repo.base.</tt><tt class="descname">Repo</tt><big>(</big><em>path=None</em>, <em>odbt=&lt;class 'gitdb.db.git.GitDB'&gt;</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a git repository and allows you to query references, 
gather commit information, generate diffs, create and clone repositories query
the log.</p>
<p>The following attributes are worth using:</p>
<p>&#8216;working_dir&#8217; is the working directory of the git command, wich is the working tree 
directory if available or the .git directory in case of bare repositories</p>
<p>&#8216;working_tree_dir&#8217; is the working tree directory, but will raise AssertionError
if we are a bare repository.</p>
<p>&#8216;git_dir&#8217; is the .git repository directoy, which is always set.</p>
<dl class="attribute">
<dt id="git.repo.base.Repo.active_branch">
<tt class="descname">active_branch</tt><a class="headerlink" href="#git.repo.base.Repo.active_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the currently active branch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Head to the active branch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.alternates">
<tt class="descname">alternates</tt><a class="headerlink" href="#git.repo.base.Repo.alternates" title="Permalink to this definition">¶</a></dt>
<dd>Retrieve a list of alternates paths or set a list paths to be used as alternates</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.archive">
<tt class="descname">archive</tt><big>(</big><em>ostream</em>, <em>treeish=None</em>, <em>prefix=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Archive the tree at the given revision.
:parm ostream: file compatible stream object to which the archive will be written
:parm treeish: is the treeish name/id, defaults to active branch
:parm prefix: is the optional prefix to prepend to each filename in the archive
:parm kwargs:</p>
<blockquote>
Additional arguments passed to git-archive
NOTE: Use the &#8216;format&#8217; argument to define the kind of format. Use 
specialized ostreams to write any format supported by python</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises GitCommandError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">in case something went wrong</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.bare">
<tt class="descname">bare</tt><a class="headerlink" href="#git.repo.base.Repo.bare" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the repository is bare</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.blame">
<tt class="descname">blame</tt><big>(</big><em>rev</em>, <em>file</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.blame" title="Permalink to this definition">¶</a></dt>
<dd><p>The blame information for the given file at the given revision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parm rev:</th><td class="field-body">revision specifier, see git-rev-parse for viable options.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list: [git.Commit, list: [&lt;line&gt;]]
A list of tuples associating a Commit object with a list of lines that 
changed within the given commit. The Commit objects will be given in order
of appearance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.branches">
<tt class="descname">branches</tt><a class="headerlink" href="#git.repo.base.Repo.branches" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <tt class="docutils literal"><span class="pre">Head</span></tt> objects representing the branch heads in
this repo</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">git.IterableList(Head,</span> <span class="pre">...)</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.clone">
<tt class="descname">clone</tt><big>(</big><em>path</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a clone from this repository.
:param path:</p>
<blockquote>
is the full path of the new repo (traditionally ends with ./&lt;name&gt;.git).</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <p>odbt = ObjectDatabase Type, allowing to determine the object database
implementation used by the returned Repo instance</p>
<p>All remaining keyword arguments are given to the git-clone command</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">git.Repo</span></tt> (the newly cloned repo)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.repo.base.Repo.clone_from">
<em class="property">classmethod </em><tt class="descname">clone_from</tt><big>(</big><em>url</em>, <em>to_path</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.clone_from" title="Permalink to this definition">¶</a></dt>
<dd>Create a clone from the given URL
:param url: valid git url, see <a class="reference external" href="http://www.kernel.org/pub/software/scm/git/docs/git-clone.html#URLS">http://www.kernel.org/pub/software/scm/git/docs/git-clone.html#URLS</a>
:param to_path: Path to which the repository should be cloned to
:param <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs: see the <tt class="docutils literal"><span class="pre">clone</span></tt> method
:return: Repo instance pointing to the cloned directory</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.commit">
<tt class="descname">commit</tt><big>(</big><em>rev=None</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.commit" title="Permalink to this definition">¶</a></dt>
<dd>The Commit object for the specified revision
:param rev: revision specifier, see git-rev-parse for viable options.
:return: <tt class="docutils literal"><span class="pre">git.Commit</span></tt></dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.config_reader">
<tt class="descname">config_reader</tt><big>(</big><em>config_level=None</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.config_reader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">GitConfigParser allowing to read the full git configuration, but not to write it</p>
<p>The configuration will include values from the system, user and repository 
configuration files.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><p class="first"><em>config_level</em> &#8211; For possible values, see config_writer method
If None, all applicable levels will be used. Specify a level in case 
you know which exact file you whish to read to prevent reading multiple files for 
instance</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">On windows, system configuration cannot currently be read as the path is 
unknown, instead the global path will be used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.config_writer">
<tt class="descname">config_writer</tt><big>(</big><em>config_level='repository'</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.config_writer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">GitConfigParser allowing to write values of the specified configuration file level.
Config writers should be retrieved, used to change the configuration ,and written 
right away as they will lock the configuration file in question and prevent other&#8217;s
to write it.</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>config_level</em> &#8211; One of the following values
system = sytem wide configuration file
global = user level configuration file
repository = configuration file for this repostory only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.create_head">
<tt class="descname">create_head</tt><big>(</big><em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.create_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new head within the repository. 
For more documentation, please see the Head.create method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">newly created Head Reference</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.create_remote">
<tt class="descname">create_remote</tt><big>(</big><em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.create_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote.</p>
<p>For more information, please see the documentation of the Remote.create 
methods</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Remote reference</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.create_tag">
<tt class="descname">create_tag</tt><big>(</big><em>path</em>, <em>ref='HEAD'</em>, <em>message=None</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.create_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new tag reference.
For more documentation, please see the TagReference.create method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">TagReference object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.daemon_export">
<tt class="descname">daemon_export</tt><a class="headerlink" href="#git.repo.base.Repo.daemon_export" title="Permalink to this definition">¶</a></dt>
<dd>If True, git-daemon may export this repository</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.delete_head">
<tt class="descname">delete_head</tt><big>(</big><em>*heads</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.delete_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given heads</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; Additional keyword arguments to be passed to git-branch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.delete_remote">
<tt class="descname">delete_remote</tt><big>(</big><em>remote</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.delete_remote" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given remote.</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.delete_tag">
<tt class="descname">delete_tag</tt><big>(</big><em>*tags</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.delete_tag" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given tag references</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.description">
<tt class="descname">description</tt><a class="headerlink" href="#git.repo.base.Repo.description" title="Permalink to this definition">¶</a></dt>
<dd>the project&#8217;s description</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.git">
<tt class="descname">git</tt><a class="headerlink" href="#git.repo.base.Repo.git" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.git_dir">
<tt class="descname">git_dir</tt><a class="headerlink" href="#git.repo.base.Repo.git_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.head">
<tt class="descname">head</tt><a class="headerlink" href="#git.repo.base.Repo.head" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">HEAD Object pointing to the current head reference</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.heads">
<tt class="descname">heads</tt><a class="headerlink" href="#git.repo.base.Repo.heads" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <tt class="docutils literal"><span class="pre">Head</span></tt> objects representing the branch heads in
this repo</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">git.IterableList(Head,</span> <span class="pre">...)</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.index">
<tt class="descname">index</tt><a class="headerlink" href="#git.repo.base.Repo.index" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">IndexFile representing this repository&#8217;s index.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="git.repo.base.Repo.init">
<em class="property">classmethod </em><tt class="descname">init</tt><big>(</big><em>path=None</em>, <em>mkdir=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a git repository at the given path if specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>path</em> &#8211; is the full path to the repo (traditionally ends with /&lt;name&gt;.git)
or None in which case the repository will be created in the current 
working directory</td>
</tr>
<tr class="field"><th class="field-name">Parm mkdir:</th><td class="field-body">if specified will create the repository directory if it doesn&#8217;t
already exists. Creates the directory with a mode=0755. 
Only effective if a path is explicitly given</td>
</tr>
<tr class="field"><th class="field-name">Parm kwargs:</th><td class="field-body">keyword arguments serving as additional options to the git-init command</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">git.Repo</span></tt> (the newly created repo)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.is_dirty">
<tt class="descname">is_dirty</tt><big>(</big><em>index=True</em>, <em>working_tree=True</em>, <em>untracked_files=False</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.is_dirty" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt>, the repository is considered dirty. By default it will react
like a git-status without untracked files, hence it is dirty if the 
index or the working copy have changes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.iter_commits">
<tt class="descname">iter_commits</tt><big>(</big><em>rev=None</em>, <em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.iter_commits" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Commit objects representing the history of a given ref/commit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parm rev:</th><td class="field-body">revision specifier, see git-rev-parse for viable options.
If None, the active branch will be used.</td>
</tr>
<tr class="field"><th class="field-name">Parm paths:</th><td class="field-body">is an optional path or a list of paths to limit the returned commits to
Commits that do not contain that path or the paths will not be returned.</td>
</tr>
<tr class="field"><th class="field-name">Parm kwargs:</th><td class="field-body">Arguments to be passed to git-rev-list - common ones are 
max_count and skip</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">to receive only commits between two named revisions, use the 
&#8220;revA..revB&#8221; revision specifier</td>
</tr>
</tbody>
</table>
<p>:return <tt class="docutils literal"><span class="pre">git.Commit[]</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.iter_trees">
<tt class="descname">iter_trees</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.iter_trees" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator yielding Tree objects</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Takes all arguments known to iter_commits method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.odb">
<tt class="descname">odb</tt><a class="headerlink" href="#git.repo.base.Repo.odb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.references">
<tt class="descname">references</tt><a class="headerlink" href="#git.repo.base.Repo.references" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Reference objects representing tags, heads and remote references.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">IterableList(Reference, ...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.refs">
<tt class="descname">refs</tt><a class="headerlink" href="#git.repo.base.Repo.refs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Reference objects representing tags, heads and remote references.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">IterableList(Reference, ...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.remote">
<tt class="descname">remote</tt><big>(</big><em>name='origin'</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.remote" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Remote with the specified name</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if no remote with such a name exists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.remotes">
<tt class="descname">remotes</tt><a class="headerlink" href="#git.repo.base.Repo.remotes" title="Permalink to this definition">¶</a></dt>
<dd>A list of Remote objects allowing to access and manipulate remotes
:return: <tt class="docutils literal"><span class="pre">git.IterableList(Remote,</span> <span class="pre">...)</span></tt></dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.rev_parse">
<tt class="descname">rev_parse</tt><big>(</big><em>repo</em>, <em>rev</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.rev_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Object at the given revision, either Commit, Tag, Tree or Blob</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>rev</em> &#8211; git-rev-parse compatible revision specification, please see
<a class="reference external" href="http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html">http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html</a>
for details</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Currently there is no access to the rev-log, rev-specs may only contain
topological tokens such ~ and ^.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises BadObject:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the given revision could not be found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.tag">
<tt class="descname">tag</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.tag" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">TagReference Object, reference pointing to a Commit or Tag</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>path</em> &#8211; path to the tag reference, i.e. 0.1.5 or tags/0.1.5</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.tags">
<tt class="descname">tags</tt><a class="headerlink" href="#git.repo.base.Repo.tags" title="Permalink to this definition">¶</a></dt>
<dd>A list of <tt class="docutils literal"><span class="pre">Tag</span></tt> objects that are available in this repo
:return: <tt class="docutils literal"><span class="pre">git.IterableList(TagReference,</span> <span class="pre">...)</span></tt></dd></dl>

<dl class="method">
<dt id="git.repo.base.Repo.tree">
<tt class="descname">tree</tt><big>(</big><em>rev=None</em><big>)</big><a class="headerlink" href="#git.repo.base.Repo.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tree object for the given treeish revision
Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">repo</span><span class="o">.</span><span class="n">tree</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>rev</em> &#8211; is a revision pointing to a Treeish ( being a commit or tree )</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">git.Tree</span></tt></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you need a non-root level tree, find it by iterating the root tree. Otherwise
it cannot know about its path relative to the repository root and subsequent 
operations might have unexpected results.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.untracked_files">
<tt class="descname">untracked_files</tt><a class="headerlink" href="#git.repo.base.Repo.untracked_files" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list(str,...)</p>
<p>Files currently untracked as they have not been staged yet. Paths 
are relative to the current working directory of the git command.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">ignored files will not appear here, i.e. files mentioned in .gitignore</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.working_dir">
<tt class="descname">working_dir</tt><a class="headerlink" href="#git.repo.base.Repo.working_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.base.Repo.working_tree_dir">
<tt class="descname">working_tree_dir</tt><a class="headerlink" href="#git.repo.base.Repo.working_tree_dir" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The working tree directory of our git repository</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises AssertionError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">If we are a bare repository</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.repo.fun">
<h2>Repo.Functions<a class="headerlink" href="#module-git.repo.fun" title="Permalink to this headline">¶</a></h2>
<p>Package with general repository related functions</p>
<dl class="function">
<dt id="git.repo.fun.rev_parse">
<tt class="descclassname">git.repo.fun.</tt><tt class="descname">rev_parse</tt><big>(</big><em>repo</em>, <em>rev</em><big>)</big><a class="headerlink" href="#git.repo.fun.rev_parse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Object at the given revision, either Commit, Tag, Tree or Blob</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>rev</em> &#8211; git-rev-parse compatible revision specification, please see
<a class="reference external" href="http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html">http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html</a>
for details</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Currently there is no access to the rev-log, rev-specs may only contain
topological tokens such ~ and ^.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises BadObject:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the given revision could not be found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.repo.fun.is_git_dir">
<tt class="descclassname">git.repo.fun.</tt><tt class="descname">is_git_dir</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#git.repo.fun.is_git_dir" title="Permalink to this definition">¶</a></dt>
<dd>This is taken from the git setup.c:is_git_directory
function.</dd></dl>

<dl class="function">
<dt id="git.repo.fun.touch">
<tt class="descclassname">git.repo.fun.</tt><tt class="descname">touch</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#git.repo.fun.touch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-git.util">
<h2>Util<a class="headerlink" href="#module-git.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="git.util.stream_copy">
<tt class="descclassname">git.util.</tt><tt class="descname">stream_copy</tt><big>(</big><em>source</em>, <em>destination</em>, <em>chunk_size=524288</em><big>)</big><a class="headerlink" href="#git.util.stream_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all data from the source stream into the destination stream in chunks
of size chunk_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">amount of bytes written</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="git.util.join_path">
<tt class="descclassname">git.util.</tt><tt class="descname">join_path</tt><big>(</big><em>a</em>, <em>*p</em><big>)</big><a class="headerlink" href="#git.util.join_path" title="Permalink to this definition">¶</a></dt>
<dd>Join path tokens together similar to os.path.join, but always use 
&#8216;/&#8217; instead of possibly &#8216;&#8217; on windows.</dd></dl>

<dl class="function">
<dt id="git.util.to_native_path_windows">
<tt class="descclassname">git.util.</tt><tt class="descname">to_native_path_windows</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.util.to_native_path_windows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="git.util.to_native_path_linux">
<tt class="descclassname">git.util.</tt><tt class="descname">to_native_path_linux</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.util.to_native_path_linux" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="git.util.join_path_native">
<tt class="descclassname">git.util.</tt><tt class="descname">join_path_native</tt><big>(</big><em>a</em>, <em>*p</em><big>)</big><a class="headerlink" href="#git.util.join_path_native" title="Permalink to this definition">¶</a></dt>
<dd>As join path, but makes sure an OS native path is returned. This is only 
needed to play it safe on my dear windows and to assure nice paths that only 
use &#8216;&#8217;</dd></dl>

<dl class="class">
<dt id="git.util.Stats">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">Stats</tt><big>(</big><em>total</em>, <em>files</em><big>)</big><a class="headerlink" href="#git.util.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents stat information as presented by git at the end of a merge. It is 
created from the output of a diff operation.</p>
<p><tt class="docutils literal"><span class="pre">Example</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">Commit</span><span class="p">(</span> <span class="n">sha1</span> <span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stats</span>
<span class="n">s</span><span class="o">.</span><span class="n">total</span>                 <span class="c"># full-stat-dict</span>
<span class="n">s</span><span class="o">.</span><span class="n">files</span>                 <span class="c"># dict( filepath : stat-dict )</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">stat-dict</span></tt></p>
<p>A dictionary with the following keys and values:</p>
<div class="highlight-python"><pre>deletions = number of deleted lines as int
insertions = number of inserted lines as int
lines = total number of lines changed as int, or deletions + insertions</pre>
</div>
<p><tt class="docutils literal"><span class="pre">full-stat-dict</span></tt></p>
<p>In addition to the items in the stat-dict, it features additional information:</p>
<div class="highlight-python"><pre>files = number of changed files as int</pre>
</div>
<dl class="attribute">
<dt id="git.util.Stats.files">
<tt class="descname">files</tt><a class="headerlink" href="#git.util.Stats.files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.util.Stats.total">
<tt class="descname">total</tt><a class="headerlink" href="#git.util.Stats.total" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.util.IndexFileSHA1Writer">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">IndexFileSHA1Writer</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#git.util.IndexFileSHA1Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around a file-like object that remembers the SHA1 of 
the data written to it. It will write a sha when the stream is closed
or if the asked for explicitly usign write_sha.</p>
<p>Only useful to the indexfile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Based on the dulwich project</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="git.util.IndexFileSHA1Writer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#git.util.IndexFileSHA1Writer.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.util.IndexFileSHA1Writer.f">
<tt class="descname">f</tt><a class="headerlink" href="#git.util.IndexFileSHA1Writer.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.util.IndexFileSHA1Writer.sha1">
<tt class="descname">sha1</tt><a class="headerlink" href="#git.util.IndexFileSHA1Writer.sha1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.util.IndexFileSHA1Writer.tell">
<tt class="descname">tell</tt><big>(</big><big>)</big><a class="headerlink" href="#git.util.IndexFileSHA1Writer.tell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.util.IndexFileSHA1Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#git.util.IndexFileSHA1Writer.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.util.IndexFileSHA1Writer.write_sha">
<tt class="descname">write_sha</tt><big>(</big><big>)</big><a class="headerlink" href="#git.util.IndexFileSHA1Writer.write_sha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.util.Iterable">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">Iterable</tt><a class="headerlink" href="#git.util.Iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an interface for iterable items which is to assure a uniform 
way to retrieve and iterate items within the git repository</p>
<dl class="classmethod">
<dt id="git.util.Iterable.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.util.Iterable.iter_items" title="Permalink to this definition">¶</a></dt>
<dd>For more information about the arguments, see list_items
:return:  iterator yielding Items</dd></dl>

<dl class="classmethod">
<dt id="git.util.Iterable.list_items">
<em class="property">classmethod </em><tt class="descname">list_items</tt><big>(</big><em>repo</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.util.Iterable.list_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all items of this type - subclasses can specify args and kwargs differently.
If no args are given, subclasses are obliged to return all items if no additional 
arguments arg given.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Favor the iter_items method as it will</td>
</tr>
</tbody>
</table>
<p>:return:list(Item,...) list of item instances</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.util.IterableList">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">IterableList</tt><big>(</big><em>id_attr</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#git.util.IterableList" title="Permalink to this definition">¶</a></dt>
<dd><p>List of iterable objects allowing to query an object by id or by named index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heads</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">heads</span>
<span class="n">heads</span><span class="o">.</span><span class="n">master</span>
<span class="n">heads</span><span class="p">[</span><span class="s">&#39;master&#39;</span><span class="p">]</span>
<span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</pre></div>
</div>
<p>It requires an id_attribute name to be set which will be queried from its 
contained items to have a means for comparison.</p>
<p>A prefix can be specified which is to be used in case the id returned by the 
items always contains a prefix that does not matter to the user, so it 
can be left out.</p>
</dd></dl>

<dl class="class">
<dt id="git.util.BlockingLockFile">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">BlockingLockFile</tt><big>(</big><em>file_path</em>, <em>check_interval_s=0.29999999999999999</em>, <em>max_block_time_s=9223372036854775807</em><big>)</big><a class="headerlink" href="#git.util.BlockingLockFile" title="Permalink to this definition">¶</a></dt>
<dd><p>The lock file will block until a lock could be obtained, or fail after 
a specified timeout.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If the directory containing the lock was removed, an exception will 
be raised during the blocking period, preventing hangs as the lock 
can never be obtained.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="git.util.LockFile">
<em class="property">class </em><tt class="descclassname">git.util.</tt><tt class="descname">LockFile</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#git.util.LockFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides methods to obtain, check for, and release a file based lock which 
should be used to handle concurrent access to the same file.</p>
<p>As we are a utility class to be derived from, we only use protected methods.</p>
<p>Locks will automatically be released on destruction</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">API Reference</a><ul>
<li><a class="reference external" href="#module-git.objects.base">Objects.Base</a></li>
<li><a class="reference external" href="#module-git.objects.blob">Objects.Blob</a></li>
<li><a class="reference external" href="#module-git.objects.commit">Objects.Commit</a></li>
<li><a class="reference external" href="#module-git.objects.tag">Objects.Tag</a></li>
<li><a class="reference external" href="#module-git.objects.tree">Objects.Tree</a></li>
<li><a class="reference external" href="#module-git.objects.fun">Objects.Functions</a></li>
<li><a class="reference external" href="#module-git.objects.submodule">Objects.Submodule</a></li>
<li><a class="reference external" href="#module-git.objects.util">Objects.Util</a></li>
<li><a class="reference external" href="#module-git.index.base">Index.Base</a></li>
<li><a class="reference external" href="#module-git.index.fun">Index.Functions</a></li>
<li><a class="reference external" href="#module-git.index.typ">Index.Types</a></li>
<li><a class="reference external" href="#module-git.index.util">Index.Util</a></li>
<li><a class="reference external" href="#module-git.cmd">GitCmd</a></li>
<li><a class="reference external" href="#module-git.config">Config</a></li>
<li><a class="reference external" href="#module-git.diff">Diff</a></li>
<li><a class="reference external" href="#module-git.errors">Errors</a></li>
<li><a class="reference external" href="#module-git.refs">Refs</a></li>
<li><a class="reference external" href="#module-git.remote">Remote</a></li>
<li><a class="reference external" href="#module-git.repo.base">Repo.Base</a></li>
<li><a class="reference external" href="#module-git.repo.fun">Repo.Functions</a></li>
<li><a class="reference external" href="#module-git.util">Util</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="tutorial.html"
                                  title="previous chapter">GitPython Tutorial</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="roadmap.html"
                                  title="next chapter">Roadmap</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/reference.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="roadmap.html" title="Roadmap"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="GitPython Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">GitPython v0.3.0-beta2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright Copyright (C) 2008, 2009 Michael Trier and contributors, 2010 Sebastian Thiel.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>