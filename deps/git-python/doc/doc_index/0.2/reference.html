<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Reference &mdash; GitPython v0.2.0 Beta documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '0.2.0 Beta',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="GitPython v0.2.0 Beta documentation" href="index.html" />
    <link rel="next" title="Roadmap" href="roadmap.html" />
    <link rel="prev" title="GitPython Tutorial" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="roadmap.html" title="Roadmap"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="GitPython Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">GitPython v0.2.0 Beta documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api-reference">
<span id="api-reference-toplevel"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-git.actor">
<h2>Actor<a class="headerlink" href="#module-git.actor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.actor.Actor">
<em class="property">class </em><tt class="descclassname">git.actor.</tt><tt class="descname">Actor</tt><big>(</big><em>name</em>, <em>email</em><big>)</big><a class="headerlink" href="#git.actor.Actor" title="Permalink to this definition">¶</a></dt>
<dd>Actors hold information about a person acting on the repository. They 
can be committers and authors or anything with a name and an email as 
mentioned in the git log entries.</dd></dl>

</div>
<div class="section" id="module-git.objects.base">
<h2>Objects.Base<a class="headerlink" href="#module-git.objects.base" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.base.IndexObject">
<em class="property">class </em><tt class="descclassname">git.objects.base.</tt><tt class="descname">IndexObject</tt><big>(</big><em>repo</em>, <em>sha</em>, <em>mode=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.base.IndexObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Base for all objects that can be part of the index file , namely Tree, Blob and
SubModule objects</p>
<dl class="attribute">
<dt id="git.objects.base.IndexObject.abspath">
<tt class="descname">abspath</tt><a class="headerlink" href="#git.objects.base.IndexObject.abspath" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd><p class="first">Absolute path to this index object in the file system ( as opposed to the 
.path field which is a path relative to the git repository ).</p>
<p class="last">The returned path will be native to the system and contains &#8216;&#8217; on windows.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#git.objects.base.IndexObject.mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.objects.base.IndexObject.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Name portion of the path, effectively being the basename</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.IndexObject.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.objects.base.IndexObject.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.objects.base.Object">
<em class="property">class </em><tt class="descclassname">git.objects.base.</tt><tt class="descname">Object</tt><big>(</big><em>repo</em>, <em>id</em><big>)</big><a class="headerlink" href="#git.objects.base.Object" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Object which may be Blobs, Trees, Commits and Tags</p>
<p>This Object also serves as a constructor for instances of the correct type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inst</span> <span class="o">=</span> <span class="n">Object</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">repo</span><span class="p">,</span><span class="nb">id</span><span class="p">)</span>
<span class="n">inst</span><span class="o">.</span><span class="n">sha</span>        <span class="c"># objects sha in hex</span>
<span class="n">inst</span><span class="o">.</span><span class="n">size</span>   <span class="c"># objects uncompressed data size</span>
<span class="n">inst</span><span class="o">.</span><span class="n">data</span>   <span class="c"># byte string containing the whole data of the object</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.objects.base.Object.data">
<tt class="descname">data</tt><a class="headerlink" href="#git.objects.base.Object.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.data_stream">
<tt class="descname">data_stream</tt><a class="headerlink" href="#git.objects.base.Object.data_stream" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns </dt>
<dd>File Object compatible stream to the uncompressed raw data of the object</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.base.Object.new">
<em class="property">classmethod </em><tt class="descname">new</tt><big>(</big><em>repo</em>, <em>id</em><big>)</big><a class="headerlink" href="#git.objects.base.Object.new" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>New Object instance of a type appropriate to the object type behind 
id. The id of the newly created object will be a hexsha even though 
the input id may have been a Reference or Rev-Spec</dd>
<dt>Note</dt>
<dd>This cannot be a __new__ method as it would always call __init__
with the input id which is not necessarily a hexsha.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.objects.base.Object.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.sha">
<tt class="descname">sha</tt><a class="headerlink" href="#git.objects.base.Object.sha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.base.Object.size">
<tt class="descname">size</tt><a class="headerlink" href="#git.objects.base.Object.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.objects.base.Object.stream_data">
<tt class="descname">stream_data</tt><big>(</big><em>ostream</em><big>)</big><a class="headerlink" href="#git.objects.base.Object.stream_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes our data directly to the given output stream</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">ostream</span></tt></dt>
<dd>File object compatible stream object.</dd>
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.blob">
<h2>Objects.Blob<a class="headerlink" href="#module-git.objects.blob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.blob.Blob">
<em class="property">class </em><tt class="descclassname">git.objects.blob.</tt><tt class="descname">Blob</tt><big>(</big><em>repo</em>, <em>sha</em>, <em>mode=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.blob.Blob" title="Permalink to this definition">¶</a></dt>
<dd><p>A Blob encapsulates a git blob object</p>
<dl class="attribute">
<dt id="git.objects.blob.Blob.mime_type">
<tt class="descname">mime_type</tt><a class="headerlink" href="#git.objects.blob.Blob.mime_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The mime type of this file (based on the filename)</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>str</dd>
<dt>NOTE</dt>
<dd>Defaults to &#8216;text/plain&#8217; in case the actual file type is unknown.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.commit">
<h2>Objects.Commit<a class="headerlink" href="#module-git.objects.commit" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.commit.Commit">
<em class="property">class </em><tt class="descclassname">git.objects.commit.</tt><tt class="descname">Commit</tt><big>(</big><em>repo</em>, <em>sha</em>, <em>tree=None</em>, <em>author=None</em>, <em>authored_date=None</em>, <em>author_tz_offset=None</em>, <em>committer=None</em>, <em>committed_date=None</em>, <em>committer_tz_offset=None</em>, <em>message=None</em>, <em>parents=None</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a git Commit object.</p>
<p>This class will act lazily on some of its attributes and will query the 
value on demand only if it involves calling the git binary.</p>
<dl class="attribute">
<dt id="git.objects.commit.Commit.author">
<tt class="descname">author</tt><a class="headerlink" href="#git.objects.commit.Commit.author" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.author_tz_offset">
<tt class="descname">author_tz_offset</tt><a class="headerlink" href="#git.objects.commit.Commit.author_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.authored_date">
<tt class="descname">authored_date</tt><a class="headerlink" href="#git.objects.commit.Commit.authored_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committed_date">
<tt class="descname">committed_date</tt><a class="headerlink" href="#git.objects.commit.Commit.committed_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committer">
<tt class="descname">committer</tt><a class="headerlink" href="#git.objects.commit.Commit.committer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.committer_tz_offset">
<tt class="descname">committer_tz_offset</tt><a class="headerlink" href="#git.objects.commit.Commit.committer_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.objects.commit.Commit.count">
<tt class="descname">count</tt><big>(</big><em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of commits reachable from this commit</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>is an optinal path or a list of paths restricting the return value 
to commits actually containing the paths</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional options to be passed to git-rev-list. They must not alter
the ouput style of the command, or parsing will yield incorrect results</dd>
<dt>Returns</dt>
<dd>int</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.commit.Commit.create_from_tree">
<em class="property">classmethod </em><tt class="descname">create_from_tree</tt><big>(</big><em>repo</em>, <em>tree</em>, <em>message</em>, <em>parent_commits=None</em>, <em>head=False</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.create_from_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the given tree, creating a commit object.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">repo</span></tt></dt>
<dd>is the Repo</dd>
<dt><tt class="docutils literal"><span class="pre">tree</span></tt></dt>
<dd>Sha of a tree or a tree object to become the tree of the new commit</dd>
<dt><tt class="docutils literal"><span class="pre">message</span></tt></dt>
<dd>Commit message. It may be an empty string if no message is provided.
It will be converted to a string in any case.</dd>
<dt><tt class="docutils literal"><span class="pre">parent_commits</span></tt></dt>
<dd>Optional Commit objects to use as parents for the new commit.
If empty list, the commit will have no parents at all and become 
a root commit.
If None , the current head commit will be the parent of the 
new commit object</dd>
<dt><tt class="docutils literal"><span class="pre">head</span></tt></dt>
<dd>If True, the HEAD will be advanced to the new commit automatically.
Else the HEAD will remain pointing on the previous commit. This could 
lead to undesired results when diffing files.</dd>
<dt>Returns</dt>
<dd>Commit object representing the new commit</dd>
<dt>Note:</dt>
<dd>Additional information about hte committer and Author are taken from the
environment or from the git configuration, see git-commit-tree for 
more information</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.objects.commit.Commit.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>rev</em>, <em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all commits matching the given criteria.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">repo</span></tt></dt>
<dd>is the Repo</dd>
<dt><tt class="docutils literal"><span class="pre">rev</span></tt></dt>
<dd>revision specifier, see git-rev-parse for viable options</dd>
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>is an optinal path or list of paths, if set only Commits that include the path 
or paths will be considered</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>optional keyword arguments to git rev-list where
<tt class="docutils literal"><span class="pre">max_count</span></tt> is the maximum number of commits to fetch
<tt class="docutils literal"><span class="pre">skip</span></tt> is the number of commits to skip
<tt class="docutils literal"><span class="pre">since</span></tt> all commits since i.e. &#8216;1970-01-01&#8217;</dd>
<dt>Returns</dt>
<dd>iterator yielding Commit items</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.objects.commit.Commit.iter_parents">
<tt class="descname">iter_parents</tt><big>(</big><em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.objects.commit.Commit.iter_parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate _all_ parents of this commit.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>Optional path or list of paths limiting the Commits to those that 
contain at least one of the paths</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>All arguments allowed by git-rev-list</dd>
<dt>Return:</dt>
<dd>Iterator yielding Commit objects which are parents of self</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.message">
<tt class="descname">message</tt><a class="headerlink" href="#git.objects.commit.Commit.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.name_rev">
<tt class="descname">name_rev</tt><a class="headerlink" href="#git.objects.commit.Commit.name_rev" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>String describing the commits hex sha based on the closest Reference.
Mostly useful for UI purposes</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.parents">
<tt class="descname">parents</tt><a class="headerlink" href="#git.objects.commit.Commit.parents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.stats">
<tt class="descname">stats</tt><a class="headerlink" href="#git.objects.commit.Commit.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a git stat from changes between this commit and its first parent 
or from all changes done if this is the very first commit.</p>
<dl class="docutils">
<dt>Return</dt>
<dd>git.Stats</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.summary">
<tt class="descname">summary</tt><a class="headerlink" href="#git.objects.commit.Commit.summary" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>First line of the commit message.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.commit.Commit.tree">
<tt class="descname">tree</tt><a class="headerlink" href="#git.objects.commit.Commit.tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.tag">
<h2>Objects.Tag<a class="headerlink" href="#module-git.objects.tag" title="Permalink to this headline">¶</a></h2>
<p>Module containing all object based types.</p>
<dl class="class">
<dt id="git.objects.tag.TagObject">
<em class="property">class </em><tt class="descclassname">git.objects.tag.</tt><tt class="descname">TagObject</tt><big>(</big><em>repo</em>, <em>sha</em>, <em>object=None</em>, <em>tag=None</em>, <em>tagger=None</em>, <em>tagged_date=None</em>, <em>tagger_tz_offset=None</em>, <em>message=None</em><big>)</big><a class="headerlink" href="#git.objects.tag.TagObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-Lightweight tag carrying additional information about an object we are pointing 
to.</p>
<dl class="attribute">
<dt id="git.objects.tag.TagObject.message">
<tt class="descname">message</tt><a class="headerlink" href="#git.objects.tag.TagObject.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.object">
<tt class="descname">object</tt><a class="headerlink" href="#git.objects.tag.TagObject.object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tag">
<tt class="descname">tag</tt><a class="headerlink" href="#git.objects.tag.TagObject.tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagged_date">
<tt class="descname">tagged_date</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagged_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagger">
<tt class="descname">tagger</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.objects.tag.TagObject.tagger_tz_offset">
<tt class="descname">tagger_tz_offset</tt><a class="headerlink" href="#git.objects.tag.TagObject.tagger_tz_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.objects.tree">
<h2>Objects.Tree<a class="headerlink" href="#module-git.objects.tree" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.objects.tree.Tree">
<em class="property">class </em><tt class="descclassname">git.objects.tree.</tt><tt class="descname">Tree</tt><big>(</big><em>repo</em>, <em>sha</em>, <em>mode=0</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#git.objects.tree.Tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Tress represent a ordered list of Blobs and other Trees. Hence it can be 
accessed like a list.</p>
<p>Tree&#8217;s will cache their contents after first retrieval to improve efficiency.</p>
<p><tt class="docutils literal"><span class="pre">Tree</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">list</span></tt>:</p>
<div class="highlight-python"><pre>Access a specific blob using the  
tree['filename'] notation.

You may as well access by index
blob = tree[0]</pre>
</div>
<dl class="attribute">
<dt id="git.objects.tree.Tree.blobs">
<tt class="descname">blobs</tt><a class="headerlink" href="#git.objects.tree.Tree.blobs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>list(Blob, ...) list of blobs directly below this tree</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.objects.tree.Tree.traverse">
<tt class="descname">traverse</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x1e0b050&gt;</em>, <em>prune=&lt;function &lt;lambda&gt; at 0x1e0b0c8&gt;</em>, <em>depth=-1</em>, <em>branch_first=True</em>, <em>visit_once=False</em>, <em>ignore_self=1</em><big>)</big><a class="headerlink" href="#git.objects.tree.Tree.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>For documentation, see utils.Traversable.traverse</p>
<p>Trees are set to visist_once = False to gain more performance in the traversal</p>
</dd></dl>

<dl class="attribute">
<dt id="git.objects.tree.Tree.trees">
<tt class="descname">trees</tt><a class="headerlink" href="#git.objects.tree.Tree.trees" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>list(Tree, ...) list of trees directly below this tree</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.objects.tree.sha_to_hex">
<tt class="descclassname">git.objects.tree.</tt><tt class="descname">sha_to_hex</tt><big>(</big><em>sha</em><big>)</big><a class="headerlink" href="#git.objects.tree.sha_to_hex" title="Permalink to this definition">¶</a></dt>
<dd>Takes a string and returns the hex of the sha within</dd></dl>

</div>
<div class="section" id="module-git.objects.utils">
<h2>Objects.Utils<a class="headerlink" href="#module-git.objects.utils" title="Permalink to this headline">¶</a></h2>
<p>Module for general utility functions</p>
<dl class="class">
<dt id="git.objects.utils.ProcessStreamAdapter">
<em class="property">class </em><tt class="descclassname">git.objects.utils.</tt><tt class="descname">ProcessStreamAdapter</tt><big>(</big><em>process</em>, <em>stream_name</em><big>)</big><a class="headerlink" href="#git.objects.utils.ProcessStreamAdapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Class wireing all calls to the contained Process instance.</p>
<p>Use this type to hide the underlying process to provide access only to a specified 
stream. The process is usually wrapped into an AutoInterrupt class to kill 
it if the instance goes out of scope.</p>
</dd></dl>

<dl class="class">
<dt id="git.objects.utils.Traversable">
<em class="property">class </em><tt class="descclassname">git.objects.utils.</tt><tt class="descname">Traversable</tt><a class="headerlink" href="#git.objects.utils.Traversable" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple interface to perforam depth-first or breadth-first traversals 
into one direction.
Subclasses only need to implement one function.
Instances of the Subclass must be hashable</p>
<dl class="method">
<dt id="git.objects.utils.Traversable.traverse">
<tt class="descname">traverse</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x1df9de8&gt;</em>, <em>prune=&lt;function &lt;lambda&gt; at 0x1df9e60&gt;</em>, <em>depth=-1</em>, <em>branch_first=True</em>, <em>visit_once=True</em>, <em>ignore_self=1</em>, <em>as_edge=False</em><big>)</big><a class="headerlink" href="#git.objects.utils.Traversable.traverse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd>iterator yieling of items found when traversing self</dd>
<dt><tt class="docutils literal"><span class="pre">predicate</span></tt></dt>
<dd>f(i,d) returns False if item i at depth d should not be included in the result</dd>
<dt><tt class="docutils literal"><span class="pre">prune</span></tt></dt>
<dd>f(i,d) return True if the search should stop at item i at depth d.
Item i will not be returned.</dd>
<dt><tt class="docutils literal"><span class="pre">depth</span></tt></dt>
<dd>define at which level the iteration should not go deeper
if -1, there is no limit
if 0, you would effectively only get self, the root of the iteration
i.e. if 1, you would only get the first level of predessessors/successors</dd>
<dt><tt class="docutils literal"><span class="pre">branch_first</span></tt></dt>
<dd>if True, items will be returned branch first, otherwise depth first</dd>
<dt><tt class="docutils literal"><span class="pre">visit_once</span></tt></dt>
<dd>if True, items will only be returned once, although they might be encountered
several times. Loops are prevented that way.</dd>
<dt><tt class="docutils literal"><span class="pre">ignore_self</span></tt></dt>
<dd>if True, self will be ignored and automatically pruned from
the result. Otherwise it will be the first item to be returned.
If as_edge is True, the source of the first edge is None</dd>
<dt><tt class="docutils literal"><span class="pre">as_edge</span></tt></dt>
<dd>if True, return a pair of items, first being the source, second the 
destinatination, i.e. tuple(src, dest) with the edge spanning from 
source to destination</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.objects.utils.get_object_type_by_name">
<tt class="descclassname">git.objects.utils.</tt><tt class="descname">get_object_type_by_name</tt><big>(</big><em>object_type_name</em><big>)</big><a class="headerlink" href="#git.objects.utils.get_object_type_by_name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>type suitable to handle the given object type name.
Use the type to create new instances.</dd>
<dt><tt class="docutils literal"><span class="pre">object_type_name</span></tt></dt>
<dd>Member of TYPES</dd>
<dt>Raises</dt>
<dd>ValueError: In case object_type_name is unknown</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="git.objects.utils.parse_actor_and_date">
<tt class="descclassname">git.objects.utils.</tt><tt class="descname">parse_actor_and_date</tt><big>(</big><em>line</em><big>)</big><a class="headerlink" href="#git.objects.utils.parse_actor_and_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse out the actor (author or committer) info from a line like:</p>
<div class="highlight-python"><pre>author Tom Preston-Werner &lt;tom@mojombo.com&gt; 1191999972 -0700</pre>
</div>
<dl class="docutils">
<dt>Returns</dt>
<dd>[Actor, int_seconds_since_epoch, int_timezone_offset]</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-git.cmd">
<h2>GitCmd<a class="headerlink" href="#module-git.cmd" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.cmd.Git">
<em class="property">class </em><tt class="descclassname">git.cmd.</tt><tt class="descname">Git</tt><big>(</big><em>working_dir=None</em><big>)</big><a class="headerlink" href="#git.cmd.Git" title="Permalink to this definition">¶</a></dt>
<dd><p>The Git class manages communication with the Git binary.</p>
<p>It provides a convenient interface to calling the Git binary, such as in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Git</span><span class="p">(</span> <span class="n">git_dir</span> <span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>                   <span class="c"># calls &#39;git init&#39; program</span>
<span class="n">rval</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ls_files</span><span class="p">()</span>        <span class="c"># calls &#39;git ls-files&#39; program</span>
</pre></div>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Debugging</span></tt></dt>
<dd>Set the GIT_PYTHON_TRACE environment variable print each invocation 
of the command to stdout.
Set its value to &#8216;full&#8217; to see details about the returned values.</dd>
</dl>
<dl class="class">
<dt id="git.cmd.Git.AutoInterrupt">
<em class="property">class </em><tt class="descname">AutoInterrupt</tt><big>(</big><em>proc</em>, <em>args</em><big>)</big><a class="headerlink" href="#git.cmd.Git.AutoInterrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Kill/Interrupt the stored process instance once this instance goes out of scope. It is 
used to prevent processes piling up in case iterators stop reading.
Besides all attributes are wired through to the contained process object.</p>
<p>The wait method was overridden to perform automatic status code checking
and possibly raise.</p>
<dl class="attribute">
<dt id="git.cmd.Git.AutoInterrupt.args">
<tt class="descname">args</tt><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.AutoInterrupt.proc">
<tt class="descname">proc</tt><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.proc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.AutoInterrupt.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#git.cmd.Git.AutoInterrupt.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for the process and return its status code.</p>
<dl class="docutils">
<dt>Raise</dt>
<dd>GitCommandError if the return status is not 0</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.cat_file_all">
<tt class="descclassname">Git.</tt><tt class="descname">cat_file_all</tt><a class="headerlink" href="#git.cmd.Git.cat_file_all" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.cat_file_header">
<tt class="descclassname">Git.</tt><tt class="descname">cat_file_header</tt><a class="headerlink" href="#git.cmd.Git.cat_file_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.cmd.Git.clear_cache">
<tt class="descclassname">Git.</tt><tt class="descname">clear_cache</tt><big>(</big><big>)</big><a class="headerlink" href="#git.cmd.Git.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all kinds of internal caches to release resources.</p>
<p>Currently persistent commands will be interrupted.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.execute">
<tt class="descclassname">Git.</tt><tt class="descname">execute</tt><big>(</big><em>command</em>, <em>istream=None</em>, <em>with_keep_cwd=False</em>, <em>with_extended_output=False</em>, <em>with_exceptions=True</em>, <em>as_process=False</em>, <em>output_stream=None</em><big>)</big><a class="headerlink" href="#git.cmd.Git.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles executing the command on the shell and consumes and returns
the returned information (stdout)</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">command</span></tt></dt>
<dd>The command argument list to execute.
It should be a string, or a sequence of program arguments. The
program to execute is the first item in the args sequence or string.</dd>
<dt><tt class="docutils literal"><span class="pre">istream</span></tt></dt>
<dd>Standard input filehandle passed to subprocess.Popen.</dd>
<dt><tt class="docutils literal"><span class="pre">with_keep_cwd</span></tt></dt>
<dd>Whether to use the current working directory from os.getcwd().
The cmd otherwise uses its own working_dir that it has been initialized
with if possible.</dd>
<dt><tt class="docutils literal"><span class="pre">with_extended_output</span></tt></dt>
<dd>Whether to return a (status, stdout, stderr) tuple.</dd>
<dt><tt class="docutils literal"><span class="pre">with_exceptions</span></tt></dt>
<dd>Whether to raise an exception when git returns a non-zero status.</dd>
<dt><tt class="docutils literal"><span class="pre">as_process</span></tt></dt>
<dd>Whether to return the created process instance directly from which 
streams can be read on demand. This will render with_extended_output and 
with_exceptions ineffective - the caller will have 
to deal with the details himself.
It is important to note that the process will be placed into an AutoInterrupt
wrapper that will interrupt the process once it goes out of scope. If you 
use the command in iterators, you should pass the whole process instance 
instead of a single stream.</dd>
<dt><tt class="docutils literal"><span class="pre">output_stream</span></tt></dt>
<dd>If set to a file-like object, data produced by the git command will be 
output to the given stream directly.
This feature only has any effect if as_process is False. Processes will
always be created with a pipe due to issues with subprocess.
This merely is a workaround as data will be copied from the 
output pipe to the given output stream directly.</dd>
</dl>
<p>Returns:</p>
<div class="highlight-python"><pre>str(output)                                   # extended_output = False (Default)
tuple(int(status), str(stdout), str(stderr)) # extended_output = True

if ouput_stream is True, the stdout value will be your output stream:
output_stream                                  # extended_output = False
tuple(int(status), output_stream, str(stderr))# extended_output = True</pre>
</div>
<dl class="docutils">
<dt>Raise</dt>
<dd>GitCommandError</dd>
<dt>NOTE</dt>
<dd>If you add additional keyword arguments to the signature of this method, 
you must update the execute_kwargs tuple housed in this module.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.get_object_data">
<tt class="descclassname">Git.</tt><tt class="descname">get_object_data</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#git.cmd.Git.get_object_data" title="Permalink to this definition">¶</a></dt>
<dd><p>As get_object_header, but returns object data as well</p>
<dl class="docutils">
<dt>Return:</dt>
<dd>(hexsha, type_string, size_as_int,data_string)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.get_object_header">
<tt class="descclassname">Git.</tt><tt class="descname">get_object_header</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#git.cmd.Git.get_object_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this method to quickly examine the type and size of the object behind 
the given ref.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>The method will only suffer from the costs of command invocation 
once and reuses the command in subsequent calls.</dd>
<dt>Return:</dt>
<dd>(hexsha, type_string, size_as_int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.cmd.Git.transform_kwargs">
<tt class="descclassname">Git.</tt><tt class="descname">transform_kwargs</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#git.cmd.Git.transform_kwargs" title="Permalink to this definition">¶</a></dt>
<dd>Transforms Python style kwargs into git command line options.</dd></dl>

<dl class="attribute">
<dt id="git.cmd.Git.working_dir">
<tt class="descclassname">Git.</tt><tt class="descname">working_dir</tt><a class="headerlink" href="#git.cmd.Git.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Git directory we are working on</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.cmd.dashify">
<tt class="descclassname">git.cmd.</tt><tt class="descname">dashify</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#git.cmd.dashify" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-git.config">
<h2>Config<a class="headerlink" href="#module-git.config" title="Permalink to this headline">¶</a></h2>
<p>Module containing module parser implementation able to properly read and write
configuration files</p>
<dl class="attribute">
<dt id="git.config.GitConfigParser">
<tt class="descclassname">git.config.</tt><tt class="descname">GitConfigParser</tt><a class="headerlink" href="#git.config.GitConfigParser" title="Permalink to this definition">¶</a></dt>
<dd>alias of <tt class="xref docutils literal"><span class="pre">write</span></tt></dd></dl>

</div>
<div class="section" id="module-git.diff">
<h2>Diff<a class="headerlink" href="#module-git.diff" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.diff.Diff">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">Diff</tt><big>(</big><em>repo</em>, <em>a_path</em>, <em>b_path</em>, <em>a_blob_id</em>, <em>b_blob_id</em>, <em>a_mode</em>, <em>b_mode</em>, <em>new_file</em>, <em>deleted_file</em>, <em>rename_from</em>, <em>rename_to</em>, <em>diff</em><big>)</big><a class="headerlink" href="#git.diff.Diff" title="Permalink to this definition">¶</a></dt>
<dd><p>A Diff contains diff information between two Trees.</p>
<p>It contains two sides a and b of the diff, members are prefixed with 
&#8220;a&#8221; and &#8220;b&#8221; respectively to inidcate that.</p>
<p>Diffs keep information about the changed blob objects, the file mode, renames, 
deletions and new files.</p>
<p>There are a few cases where None has to be expected as member variable value:</p>
<p><tt class="docutils literal"><span class="pre">New</span> <span class="pre">File</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a_mode</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">a_blob</span> <span class="ow">is</span> <span class="bp">None</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Deleted</span> <span class="pre">File</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b_mode</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">b_blob</span> <span class="ow">is</span> <span class="bp">None</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Working</span> <span class="pre">Tree</span> <span class="pre">Blobs</span></tt></p>
<blockquote>
When comparing to working trees, the working tree blob will have a null hexsha
as a corresponding object does not yet exist. The mode will be null as well.
But the path will be available though. 
If it is listed in a diff the working tree version of the file must 
be different to the version in the index or tree, and hence has been modified.</blockquote>
<dl class="attribute">
<dt id="git.diff.Diff.a_blob">
<tt class="descname">a_blob</tt><a class="headerlink" href="#git.diff.Diff.a_blob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.a_mode">
<tt class="descname">a_mode</tt><a class="headerlink" href="#git.diff.Diff.a_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.b_blob">
<tt class="descname">b_blob</tt><a class="headerlink" href="#git.diff.Diff.b_blob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.b_mode">
<tt class="descname">b_mode</tt><a class="headerlink" href="#git.diff.Diff.b_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.deleted_file">
<tt class="descname">deleted_file</tt><a class="headerlink" href="#git.diff.Diff.deleted_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.diff">
<tt class="descname">diff</tt><a class="headerlink" href="#git.diff.Diff.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.new_file">
<tt class="descname">new_file</tt><a class="headerlink" href="#git.diff.Diff.new_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.rename_from">
<tt class="descname">rename_from</tt><a class="headerlink" href="#git.diff.Diff.rename_from" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.rename_to">
<tt class="descname">rename_to</tt><a class="headerlink" href="#git.diff.Diff.rename_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.diff.Diff.renamed">
<tt class="descname">renamed</tt><a class="headerlink" href="#git.diff.Diff.renamed" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns:</dt>
<dd>True if the blob of our diff has been renamed</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.diff.DiffIndex">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">DiffIndex</tt><a class="headerlink" href="#git.diff.DiffIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Index for diffs, allowing a list of Diffs to be queried by 
the diff properties.</p>
<p>The class improves the diff handling convenience</p>
<dl class="method">
<dt id="git.diff.DiffIndex.iter_change_type">
<tt class="descname">iter_change_type</tt><big>(</big><em>change_type</em><big>)</big><a class="headerlink" href="#git.diff.DiffIndex.iter_change_type" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>iterator yieling Diff instances that match the given change_type</dd>
<dt><tt class="docutils literal"><span class="pre">change_type</span></tt></dt>
<dd><p class="first">Member of DiffIndex.change_type, namely</p>
<p>&#8216;A&#8217; for added paths</p>
<p>&#8216;D&#8217; for deleted paths</p>
<p>&#8216;R&#8217; for renamed paths</p>
<p class="last">&#8216;M&#8217; for paths with modified data</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.diff.Diffable">
<em class="property">class </em><tt class="descclassname">git.diff.</tt><tt class="descname">Diffable</tt><a class="headerlink" href="#git.diff.Diffable" title="Permalink to this definition">¶</a></dt>
<dd><p>Common interface for all object that can be diffed against another object of compatible type.</p>
<dl class="docutils">
<dt>NOTE: </dt>
<dd>Subclasses require a repo member as it is the case for Object instances, for practical 
reasons we do not derive from Object.</dd>
</dl>
<dl class="class">
<dt id="git.diff.Diffable.Index">
<em class="property">class </em><tt class="descname">Index</tt><a class="headerlink" href="#git.diff.Diffable.Index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.diff.Diffable.diff">
<tt class="descclassname">Diffable.</tt><tt class="descname">diff</tt><big>(</big><em>other=&lt;class 'git.diff.Index'&gt;</em>, <em>paths=None</em>, <em>create_patch=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.diff.Diffable.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates diffs between two items being trees, trees and index or an 
index and the working tree.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">other</span></tt></dt>
<dd>Is the item to compare us with. 
If None, we will be compared to the working tree.
If Treeish, it will be compared against the respective tree
If Index ( type ), it will be compared against the index.
It defaults to Index to assure the method will not by-default fail
on bare repositories.</dd>
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>is a list of paths or a single path to limit the diff to.
It will only include at least one of the givne path or paths.</dd>
<dt><tt class="docutils literal"><span class="pre">create_patch</span></tt></dt>
<dd>If True, the returned Diff contains a detailed patch that if applied
makes the self to other. Patches are somwhat costly as blobs have to be read
and diffed.</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional arguments passed to git-diff, such as 
R=True to swap both sides of the diff.</dd>
<dt>Returns</dt>
<dd>git.DiffIndex</dd>
<dt>Note</dt>
<dd><p class="first">Rename detection will only work if create_patch is True.</p>
<p class="last">On a bare repository, &#8216;other&#8217; needs to be provided as Index or as 
as Tree/Commit, or a git command error will occour</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.errors">
<h2>Errors<a class="headerlink" href="#module-git.errors" title="Permalink to this headline">¶</a></h2>
<p>Module containing all exceptions thrown througout the git package,</p>
<dl class="exception">
<dt id="git.errors.GitCommandError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">GitCommandError</tt><big>(</big><em>command</em>, <em>status</em>, <em>stderr=None</em><big>)</big><a class="headerlink" href="#git.errors.GitCommandError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if execution of the git command fails with non-zero status code.</dd></dl>

<dl class="exception">
<dt id="git.errors.InvalidGitRepositoryError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">InvalidGitRepositoryError</tt><a class="headerlink" href="#git.errors.InvalidGitRepositoryError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if the given repository appears to have an invalid format.</dd></dl>

<dl class="exception">
<dt id="git.errors.NoSuchPathError">
<em class="property">exception </em><tt class="descclassname">git.errors.</tt><tt class="descname">NoSuchPathError</tt><a class="headerlink" href="#git.errors.NoSuchPathError" title="Permalink to this definition">¶</a></dt>
<dd>Thrown if a path could not be access by the system.</dd></dl>

</div>
<div class="section" id="module-git.index">
<h2>Index<a class="headerlink" href="#module-git.index" title="Permalink to this headline">¶</a></h2>
<p>Module containing Index implementation, allowing to perform all kinds of index
manipulations such as querying and merging.</p>
<dl class="class">
<dt id="git.index.BaseIndexEntry">
<em class="property">class </em><tt class="descclassname">git.index.</tt><tt class="descname">BaseIndexEntry</tt><a class="headerlink" href="#git.index.BaseIndexEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Small Brother of an index entry which can be created to describe changes
done to the index in which case plenty of additional information is not requried.</p>
<p>As the first 4 data members match exactly to the IndexEntry type, methods
expecting a BaseIndexEntry can also handle full IndexEntries even if they
use numeric indices for performance reasons.</p>
<dl class="classmethod">
<dt id="git.index.BaseIndexEntry.from_blob">
<em class="property">classmethod </em><tt class="descname">from_blob</tt><big>(</big><em>blob</em>, <em>stage=0</em><big>)</big><a class="headerlink" href="#git.index.BaseIndexEntry.from_blob" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Fully equipped BaseIndexEntry at the given stage</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.index.BaseIndexEntry.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#git.index.BaseIndexEntry.mode" title="Permalink to this definition">¶</a></dt>
<dd>File Mode, compatible to stat module constants</dd></dl>

<dl class="attribute">
<dt id="git.index.BaseIndexEntry.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.index.BaseIndexEntry.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.BaseIndexEntry.sha">
<tt class="descname">sha</tt><a class="headerlink" href="#git.index.BaseIndexEntry.sha" title="Permalink to this definition">¶</a></dt>
<dd>hex sha of the blob</dd></dl>

<dl class="attribute">
<dt id="git.index.BaseIndexEntry.stage">
<tt class="descname">stage</tt><a class="headerlink" href="#git.index.BaseIndexEntry.stage" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Stage of the entry, either:</dt>
<dd>0 = default stage
1 = stage before a merge or common ancestor entry in case of a 3 way merge
2 = stage of entries from the &#8216;left&#8217; side of the merge
3 = stage of entries from the right side of the merge</dd>
<dt>Note:</dt>
<dd>For more information, see <a class="reference external" href="http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html">http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html</a></dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.index.BlobFilter">
<em class="property">class </em><tt class="descclassname">git.index.</tt><tt class="descname">BlobFilter</tt><big>(</big><em>paths</em><big>)</big><a class="headerlink" href="#git.index.BlobFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to be used by iter_blobs allowing to filter only return blobs which
match the given list of directories or files.</p>
<p>The given paths are given relative to the repository.</p>
<dl class="attribute">
<dt id="git.index.BlobFilter.paths">
<tt class="descname">paths</tt><a class="headerlink" href="#git.index.BlobFilter.paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="git.index.CheckoutError">
<em class="property">exception </em><tt class="descclassname">git.index.</tt><tt class="descname">CheckoutError</tt><big>(</big><em>message</em>, <em>failed_files</em>, <em>valid_files</em>, <em>failed_reasons</em><big>)</big><a class="headerlink" href="#git.index.CheckoutError" title="Permalink to this definition">¶</a></dt>
<dd><p>Thrown if a file could not be checked out from the index as it contained
changes.</p>
<p>The .failed_files attribute contains a list of relative paths that failed
to be checked out as they contained changes that did not exist in the index.</p>
<p>The .failed_reasons attribute contains a string informing about the actual
cause of the issue.</p>
<p>The .valid_files attribute contains a list of relative paths to files that
were checked out successfully and hence match the version stored in the
index</p>
</dd></dl>

<dl class="class">
<dt id="git.index.IndexEntry">
<em class="property">class </em><tt class="descclassname">git.index.</tt><tt class="descname">IndexEntry</tt><a class="headerlink" href="#git.index.IndexEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows convenient access to IndexEntry data without completely unpacking it.</p>
<p>Attributes usully accessed often are cached in the tuple whereas others are
unpacked on demand.</p>
<p>See the properties for a mapping between names and tuple indices.</p>
<dl class="attribute">
<dt id="git.index.IndexEntry.ctime">
<tt class="descname">ctime</tt><a class="headerlink" href="#git.index.IndexEntry.ctime" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Tuple(int_time_seconds_since_epoch, int_nano_seconds) of the
file&#8217;s creation time</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.dev">
<tt class="descname">dev</tt><a class="headerlink" href="#git.index.IndexEntry.dev" title="Permalink to this definition">¶</a></dt>
<dd>Device ID</dd></dl>

<dl class="classmethod">
<dt id="git.index.IndexEntry.from_base">
<em class="property">classmethod </em><tt class="descname">from_base</tt><big>(</big><em>base</em><big>)</big><a class="headerlink" href="#git.index.IndexEntry.from_base" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Minimal entry as created from the given BaseIndexEntry instance.
Missing values will be set to null-like values</dd>
<dt><tt class="docutils literal"><span class="pre">base</span></tt></dt>
<dd>Instance of type BaseIndexEntry</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.index.IndexEntry.from_blob">
<em class="property">classmethod </em><tt class="descname">from_blob</tt><big>(</big><em>blob</em><big>)</big><a class="headerlink" href="#git.index.IndexEntry.from_blob" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Minimal entry resembling the given blob objecft</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.gid">
<tt class="descname">gid</tt><a class="headerlink" href="#git.index.IndexEntry.gid" title="Permalink to this definition">¶</a></dt>
<dd>Group ID</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.inode">
<tt class="descname">inode</tt><a class="headerlink" href="#git.index.IndexEntry.inode" title="Permalink to this definition">¶</a></dt>
<dd>Inode ID</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.mtime">
<tt class="descname">mtime</tt><a class="headerlink" href="#git.index.IndexEntry.mtime" title="Permalink to this definition">¶</a></dt>
<dd>See ctime property, but returns modification time</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.size">
<tt class="descname">size</tt><a class="headerlink" href="#git.index.IndexEntry.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncompressed size of the blob</p>
<dl class="docutils">
<dt>Note</dt>
<dd>Will be 0 if the stage is not 0 ( hence it is an unmerged entry )</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexEntry.uid">
<tt class="descname">uid</tt><a class="headerlink" href="#git.index.IndexEntry.uid" title="Permalink to this definition">¶</a></dt>
<dd>User ID</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.index.IndexFile">
<em class="property">class </em><tt class="descclassname">git.index.</tt><tt class="descname">IndexFile</tt><big>(</big><em>repo</em>, <em>file_path=None</em><big>)</big><a class="headerlink" href="#git.index.IndexFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an Index that can be manipulated using a native implementation in
order to save git command function calls wherever possible.</p>
<p>It provides custom merging facilities allowing to merge without actually changing
your index or your working tree. This way you can perform own test-merges based
on the index only without having to deal with the working copy. This is useful
in case of partial working trees.</p>
<p><tt class="docutils literal"><span class="pre">Entries</span></tt>
The index contains an entries dict whose keys are tuples of type IndexEntry
to facilitate access.</p>
<dl class="docutils">
<dt>You may read the entries dict or manipulate it using IndexEntry instance, i.e.::</dt>
<dd>index.entries[index.get_entries_key(index_entry_instance)] = index_entry_instance</dd>
</dl>
<p>Otherwise changes to it will be lost when changing the index using its methods.</p>
<dl class="method">
<dt id="git.index.IndexFile.add">
<tt class="descname">add</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.checkout">
<tt class="descname">checkout</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.checkout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.commit">
<tt class="descname">commit</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.commit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.diff">
<tt class="descname">diff</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.IndexFile.entries">
<tt class="descname">entries</tt><a class="headerlink" href="#git.index.IndexFile.entries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.index.IndexFile.from_tree">
<em class="property">classmethod </em><tt class="descname">from_tree</tt><big>(</big><em>repo</em>, <em>*treeish</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.from_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the given treeish revisions into a new index which is returned.
The original index will remain unaltered</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">repo</span></tt></dt>
<dd>The repository treeish are located in.</dd>
<dt><tt class="docutils literal"><span class="pre">*treeish</span></tt></dt>
<dd><p class="first">One, two or three Tree Objects or Commits. The result changes according to the
amount of trees.
If 1 Tree is given, it will just be read into a new index
If 2 Trees are given, they will be merged into a new index using a</p>
<blockquote class="last">
two way merge algorithm. Tree 1 is the &#8216;current&#8217; tree, tree 2 is the &#8216;other&#8217;
one. It behaves like a fast-forward.
If 3 Trees are given, a 3-way merge will be performed with the first tree
being the common ancestor of tree 2 and tree 3. Tree 2 is the &#8216;current&#8217; tree,
tree 3 is the &#8216;other&#8217; one</blockquote>
</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments passed to git-read-tree</dd>
<dt>Returns</dt>
<dd>New IndexFile instance. It will point to a temporary index location which
does not exist anymore. If you intend to write such a merged Index, supply
an alternate file_path to its &#8216;write&#8217; method.</dd>
<dt>Note:</dt>
<dd><p class="first">In the three-way merge case, &#8211;aggressive will be specified to automatically
resolve more cases in a commonly correct manner. Specify trivial=True as kwarg
to override that.</p>
<p class="last">As the underlying git-read-tree command takes into account the current index,
it will be temporarily moved out of the way to assure there are no unsuspected
interferences.</p>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.index.IndexFile.get_entries_key">
<em class="property">classmethod </em><tt class="descname">get_entries_key</tt><big>(</big><em>*entry</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.get_entries_key" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Key suitable to be used for the index.entries dictionary</dd>
<dt><tt class="docutils literal"><span class="pre">entry</span></tt></dt>
<dd>One instance of type BaseIndexEntry or the path and the stage</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.iter_blobs">
<tt class="descname">iter_blobs</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x1e3ee60&gt;</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.iter_blobs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Iterator yielding tuples of Blob objects and stages, tuple(stage, Blob)</dd>
<dt><tt class="docutils literal"><span class="pre">predicate</span></tt></dt>
<dd>Function(t) returning True if tuple(stage, Blob) should be yielded by the
iterator. A default filter, the BlobFilter, allows you to yield blobs
only if they match a given list of paths.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.merge_tree">
<tt class="descname">merge_tree</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.merge_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.move">
<tt class="descname">move</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.move" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.IndexFile.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.index.IndexFile.path" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Path to the index file we are representing</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.remove">
<tt class="descname">remove</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.index.IndexFile.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.index.IndexFile.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.reset">
<tt class="descname">reset</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.resolve_blobs">
<tt class="descname">resolve_blobs</tt><big>(</big><em>iter_blobs</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.resolve_blobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the blobs given in blob iterator. This will effectively remove the
index entries of the respective path at all non-null stages and add the given
blob as new stage null blob.</p>
<p>For each path there may only be one blob, otherwise a ValueError will be raised
claiming the path is already at stage 0.</p>
<dl class="docutils">
<dt>Raise</dt>
<dd>ValueError if one of the blobs already existed at stage 0</dd>
<dt>Returns:</dt>
<dd>self</dd>
<dt>Note</dt>
<dd>You will have to write the index manually once you are done, i.e.
index.resolve_blobs(blobs).write()</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.unmerged_blobs">
<tt class="descname">unmerged_blobs</tt><big>(</big><big>)</big><a class="headerlink" href="#git.index.IndexFile.unmerged_blobs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Iterator yielding dict(path : list( tuple( stage, Blob, ...))), being
a dictionary associating a path in the index with a list containing
sorted stage/blob pairs</dd>
<dt>Note:</dt>
<dd>Blobs that have been removed in one side simply do not exist in the
given stage. I.e. a file removed on the &#8216;other&#8217; branch whose entries
are at stage 3 will not have a stage 3 entry.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#git.index.IndexFile.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Reread the contents of our index file, discarding all cached information
we might have.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This is a possibly dangerious operations as it will discard your changes
to index.entries</dd>
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.index.IndexFile.version">
<tt class="descname">version</tt><a class="headerlink" href="#git.index.IndexFile.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.write">
<tt class="descname">write</tt><big>(</big><em>file_path=None</em>, <em>ignore_tree_extension_data=False</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the current state to our file path or to the given one</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">file_path</span></tt></dt>
<dd>If None, we will write to our stored file path from which we have
been initialized. Otherwise we write to the given file path.
Please note that this will change the file_path of this index to
the one you gave.</dd>
<dt><tt class="docutils literal"><span class="pre">ignore_tree_extension_data</span></tt></dt>
<dd>If True, the TREE type extension data read in the index will not
be written to disk. Use this if you have altered the index and
would like to use git-write-tree afterwards to create a tree
representing your written changes.
If this data is present in the written index, git-write-tree
will instead write the stored/cached tree.
Alternatively, use IndexFile.write_tree() to handle this case
automatically</dd>
<dt>Returns</dt>
<dd>self</dd>
<dt>Note</dt>
<dd>Index writing based on the dulwich implementation</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.index.IndexFile.write_tree">
<tt class="descname">write_tree</tt><big>(</big><em>missing_ok=False</em><big>)</big><a class="headerlink" href="#git.index.IndexFile.write_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the Index in self to a corresponding Tree file into the repository
object database and returns it as corresponding Tree object.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">missing_ok</span></tt></dt>
<dd>If True, missing objects referenced by this index will not result
in an error.</dd>
<dt>Returns</dt>
<dd>Tree object representing this index</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.index.clear_cache">
<tt class="descclassname">git.index.</tt><tt class="descname">clear_cache</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#git.index.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for functions that alter the index using the git command. This would
invalidate our possibly existing entries dictionary which is why it must be
deleted to allow it to be lazily reread later.</p>
<dl class="docutils">
<dt>Note</dt>
<dd>This decorator will not be required once all functions are implemented
natively which in fact is possible, but probably not feasible performance wise.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="git.index.default_index">
<tt class="descclassname">git.index.</tt><tt class="descname">default_index</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#git.index.default_index" title="Permalink to this definition">¶</a></dt>
<dd>Decorator assuring the wrapped method may only run if we are the default
repository index. This is as we rely on git commands that operate
on that index only.</dd></dl>

</div>
<div class="section" id="module-git.refs">
<h2>Refs<a class="headerlink" href="#module-git.refs" title="Permalink to this headline">¶</a></h2>
<p>Module containing all ref based objects</p>
<dl class="class">
<dt id="git.refs.HEAD">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">HEAD</tt><big>(</big><em>repo</em>, <em>path='HEAD'</em><big>)</big><a class="headerlink" href="#git.refs.HEAD" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of a Symbolic Reference as it represents the repository&#8217;s 
HEAD reference.</p>
<dl class="method">
<dt id="git.refs.HEAD.reset">
<tt class="descname">reset</tt><big>(</big><em>commit='HEAD'</em>, <em>index=True</em>, <em>working_tree=False</em>, <em>paths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.HEAD.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset our HEAD to the given commit optionally synchronizing 
the index and working tree. The reference we refer to will be set to 
commit as well.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">commit</span></tt></dt>
<dd>Commit object, Reference Object or string identifying a revision we 
should reset HEAD to.</dd>
<dt><tt class="docutils literal"><span class="pre">index</span></tt></dt>
<dd>If True, the index will be set to match the given commit. Otherwise
it will not be touched.</dd>
<dt><tt class="docutils literal"><span class="pre">working_tree</span></tt></dt>
<dd>If True, the working tree will be forcefully adjusted to match the given
commit, possibly overwriting uncommitted changes without warning.
If working_tree is True, index must be true as well</dd>
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>Single path or list of paths relative to the git root directory
that are to be reset. This allow to partially reset individual files.</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional arguments passed to git-reset.</dd>
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.Head">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">Head</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.Head" title="Permalink to this definition">¶</a></dt>
<dd><p>A Head is a named reference to a Commit. Every Head instance contains a name
and a Commit object.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span> <span class="o">=</span> <span class="n">Repo</span><span class="p">(</span><span class="s">&quot;/path/to/repo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">name</span>       
<span class="go">&#39;master&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">commit</span>     
<span class="go">&lt;git.Commit &quot;1c09f116cbc2cb4100fb6935bb162daa4723f455&quot;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="o">.</span><span class="n">commit</span><span class="o">.</span><span class="n">sha</span>
<span class="go">&#39;1c09f116cbc2cb4100fb6935bb162daa4723f455&#39;</span>
</pre></div>
</div>
<dl class="method">
<dt id="git.refs.Head.checkout">
<tt class="descname">checkout</tt><big>(</big><em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.checkout" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkout this head by setting the HEAD to this reference, by updating the index
to reflect the tree we point to and by updating the working tree to reflect 
the latest index.</p>
<p>The command will fail if changed working tree files would be overwritten.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>If True, changes to the index and the working tree will be discarded.
If False, GitCommandError will be raised in that situation.</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional keyword arguments to be passed to git checkout, i.e.
b=&#8217;new_branch&#8217; to create a new branch at the given spot.</dd>
<dt>Returns</dt>
<dd>The active branch after the checkout operation, usually self unless
a new branch has been created.</dd>
<dt>Note</dt>
<dd>By default it is only allowed to checkout heads - everything else
will leave the HEAD detached which is allowed and possible, but remains
a special state that some tools might not be able to handle.</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Head.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new head.
<tt class="docutils literal"><span class="pre">repo</span></tt></p>
<blockquote>
Repository to create the head in</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>The name or path of the head, i.e. &#8216;new_branch&#8217; or 
feature/feature1. The prefix refs/heads is implied.</dd>
<dt><tt class="docutils literal"><span class="pre">commit</span></tt></dt>
<dd>Commit to which the new head should point, defaults to the 
current HEAD</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>if True, force creation even if branch with that  name already exists.</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional keyword arguments to be passed to git-branch, i.e.
track, no-track, l</dd>
<dt>Returns</dt>
<dd>Newly created Head</dd>
<dt>Note</dt>
<dd>This does not alter the current HEAD, index or Working Tree</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Head.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*heads</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.Head.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given heads</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>If True, the heads will be deleted even if they are not yet merged into
the main development stream.
Default False</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.refs.Head.rename">
<tt class="descname">rename</tt><big>(</big><em>new_path</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.Head.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename self to a new path</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">new_path</span></tt></dt>
<dd>Either a simple name or a path, i.e. new_name or features/new_name.
The prefix refs/heads is implied</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>If True, the rename will succeed even if a head with the target name
already exists.</dd>
<dt>Returns</dt>
<dd>self</dd>
<dt>Note</dt>
<dd>respects the ref log as git commands are used</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.Reference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">Reference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.Reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a named reference to any object. Subclasses may apply restrictions though, 
i.e. Heads can only point to commits.</p>
<dl class="classmethod">
<dt id="git.refs.Reference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.Reference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new reference.
<tt class="docutils literal"><span class="pre">repo</span></tt></p>
<blockquote>
Repository to create the reference in</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>The relative path of the reference, i.e. &#8216;new_branch&#8217; or 
feature/feature1. The path prefix &#8216;refs/&#8217; is implied if not 
given explicitly</dd>
<dt><tt class="docutils literal"><span class="pre">commit</span></tt></dt>
<dd>Commit to which the new reference should point, defaults to the 
current HEAD</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>if True, force creation even if a reference with that  name already exists.
Raise OSError otherwise</dd>
<dt>Returns</dt>
<dd>Newly created Reference</dd>
<dt>Note</dt>
<dd>This does not alter the current HEAD, index or Working Tree</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.Reference.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>common_path=None</em><big>)</big><a class="headerlink" href="#git.refs.Reference.iter_items" title="Permalink to this definition">¶</a></dt>
<dd>Equivalent to SymbolicReference.iter_items, but will return non-detached
references as well.</dd></dl>

<dl class="attribute">
<dt id="git.refs.Reference.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.refs.Reference.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>(shortest) Name of this reference - it may contain path components</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.Reference.object">
<tt class="descname">object</tt><a class="headerlink" href="#git.refs.Reference.object" title="Permalink to this definition">¶</a></dt>
<dd>Return the object our ref currently refers to</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.RemoteReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">RemoteReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.RemoteReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a reference pointing to a remote head.</p>
<dl class="classmethod">
<dt id="git.refs.RemoteReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*refs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.RemoteReference.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given remote references.</p>
<dl class="docutils">
<dt>Note</dt>
<dd>kwargs are given for compatability with the base class method as we 
should not narrow the signature.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.RemoteReference.remote_head">
<tt class="descname">remote_head</tt><a class="headerlink" href="#git.refs.RemoteReference.remote_head" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Name of the remote head itself, i.e. master.</dd>
</dl>
<p>NOTE: The returned name is usually not qualified enough to uniquely identify
a branch</p>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.RemoteReference.remote_name">
<tt class="descname">remote_name</tt><a class="headerlink" href="#git.refs.RemoteReference.remote_name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Name of the remote we are a reference of, such as &#8216;origin&#8217; for a reference
named &#8216;origin/master&#8217;</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.refs.SymbolicReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">SymbolicReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a special case of a reference such that this reference is symbolic.
It does not point to a specific commit, but to another Head, which itself 
specifies a commit.</p>
<p>A typical example for a symbolic reference is HEAD.</p>
<dl class="attribute">
<dt id="git.refs.SymbolicReference.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.refs.SymbolicReference.commit" title="Permalink to this definition">¶</a></dt>
<dd>Query or set commits directly</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>reference='HEAD'</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new symbolic reference, hence a reference pointing to another 
reference.
<tt class="docutils literal"><span class="pre">repo</span></tt></p>
<blockquote>
Repository to create the reference in</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>full path at which the new symbolic reference is supposed to be 
created at, i.e. &#8220;NEW_HEAD&#8221; or &#8220;symrefs/my_new_symref&#8221;</dd>
<dt><tt class="docutils literal"><span class="pre">reference</span></tt></dt>
<dd>The reference to which the new symbolic reference should point to</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>if True, force creation even if a symbolic reference with that name already exists.
Raise OSError otherwise</dd>
<dt>Returns</dt>
<dd>Newly created symbolic Reference</dd>
<dt>Raises OSError  </dt>
<dd>If a (Symbolic)Reference with the same name but different contents
already exists.</dd>
<dt>Note</dt>
<dd>This does not alter the current HEAD, index or Working Tree</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the reference at the given path</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">repo</span></tt></dt>
<dd>Repository to delete the reference from</dd>
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>Short or full path pointing to the reference, i.e. refs/myreference
or just &#8220;myreference&#8221;, hence &#8216;refs/&#8217; is implied.
Alternatively the symbolic reference to be deleted</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.from_path">
<em class="property">classmethod </em><tt class="descname">from_path</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.from_path" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>Instance of type Reference, Head, or Tag
depending on the given path</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.is_detached">
<tt class="descname">is_detached</tt><a class="headerlink" href="#git.refs.SymbolicReference.is_detached" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>True if we are a detached reference, hence we point to a specific commit
instead to another reference</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.refs.SymbolicReference.is_valid">
<tt class="descname">is_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>True if the reference is valid, hence it can be read and points to 
a valid object or reference.</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>common_path=None</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all refs in the repository</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">repo</span></tt></dt>
<dd>is the Repo</dd>
<dt><tt class="docutils literal"><span class="pre">common_path</span></tt></dt>
<dd>Optional keyword argument to the path which is to be shared by all
returned Ref objects.
Defaults to class specific portion if None assuring that only 
refs suitable for the actual class are returned.</dd>
<dt>Returns</dt>
<dd><p class="first">git.SymbolicReference[], each of them is guaranteed to be a symbolic
ref which is not detached.</p>
<p class="last">List is lexigraphically sorted
The returned objects represent actual subclasses, such as Head or TagReference</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.refs.SymbolicReference.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>In case of symbolic references, the shortest assumable name 
is the path itself.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.path">
<tt class="descname">path</tt><a class="headerlink" href="#git.refs.SymbolicReference.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.ref">
<tt class="descname">ref</tt><a class="headerlink" href="#git.refs.SymbolicReference.ref" title="Permalink to this definition">¶</a></dt>
<dd>Returns the Reference we point to</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.reference">
<tt class="descname">reference</tt><a class="headerlink" href="#git.refs.SymbolicReference.reference" title="Permalink to this definition">¶</a></dt>
<dd>Returns the Reference we point to</dd></dl>

<dl class="method">
<dt id="git.refs.SymbolicReference.rename">
<tt class="descname">rename</tt><big>(</big><em>new_path</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename self to a new path</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">new_path</span></tt></dt>
<dd>Either a simple name or a full path, i.e. new_name or features/new_name.
The prefix refs/ is implied for references and will be set as needed.
In case this is a symbolic ref, there is no implied prefix</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>If True, the rename will succeed even if a head with the target name
already exists. It will be overwritten in that case</dd>
<dt>Returns</dt>
<dd>self</dd>
<dt>Raises OSError:</dt>
<dd>In case a file at path but a different contents already exists</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.refs.SymbolicReference.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.refs.SymbolicReference.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.refs.SymbolicReference.to_full_path">
<em class="property">classmethod </em><tt class="descname">to_full_path</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.refs.SymbolicReference.to_full_path" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">string with a full path name which can be used to initialize</td>
</tr>
</tbody>
</table>
<p>a Reference instance, for instance by using <tt class="docutils literal"><span class="pre">Reference.from_path</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="git.refs.Tag">
<tt class="descclassname">git.refs.</tt><tt class="descname">Tag</tt><a class="headerlink" href="#git.refs.Tag" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="git.refs.TagReference" class="reference internal" href="#git.refs.TagReference"><tt class="xref docutils literal"><span class="pre">TagReference</span></tt></a></dd></dl>

<dl class="class">
<dt id="git.refs.TagReference">
<em class="property">class </em><tt class="descclassname">git.refs.</tt><tt class="descname">TagReference</tt><big>(</big><em>repo</em>, <em>path</em><big>)</big><a class="headerlink" href="#git.refs.TagReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a lightweight tag reference which either points to a commit 
,a tag object or any other object. In the latter case additional information, 
like the signature or the tag-creator, is available.</p>
<p>This tag object will always point to a commit object, but may carray additional
information in a tag object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tagref</span> <span class="o">=</span> <span class="n">TagReference</span><span class="o">.</span><span class="n">list_items</span><span class="p">(</span><span class="n">repo</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>
<span class="k">print</span> <span class="n">tagref</span><span class="o">.</span><span class="n">commit</span><span class="o">.</span><span class="n">message</span>
<span class="k">if</span> <span class="n">tagref</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
   <span class="k">print</span> <span class="n">tagref</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">message</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.refs.TagReference.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.refs.TagReference.commit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Commit object the tag ref points to</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.TagReference.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>path</em>, <em>ref='HEAD'</em>, <em>message=None</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.refs.TagReference.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new tag reference.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>The name of the tag, i.e. 1.0 or releases/1.0. 
The prefix refs/tags is implied</dd>
<dt><tt class="docutils literal"><span class="pre">ref</span></tt></dt>
<dd>A reference to the object you want to tag. It can be a commit, tree or 
blob.</dd>
<dt><tt class="docutils literal"><span class="pre">message</span></tt></dt>
<dd><p class="first">If not None, the message will be used in your tag object. This will also 
create an additional tag object that allows to obtain that information, i.e.:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">tagref</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">message</span>
</pre></div>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">force</span></tt></dt>
<dd>If True, to force creation of a tag even though that tag already exists.</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional keyword arguments to be passed to git-tag</dd>
<dt>Returns</dt>
<dd>A new TagReference</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.refs.TagReference.delete">
<em class="property">classmethod </em><tt class="descname">delete</tt><big>(</big><em>repo</em>, <em>*tags</em><big>)</big><a class="headerlink" href="#git.refs.TagReference.delete" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given existing tag or tags</dd></dl>

<dl class="attribute">
<dt id="git.refs.TagReference.tag">
<tt class="descname">tag</tt><a class="headerlink" href="#git.refs.TagReference.tag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Tag object this tag ref points to or None in case 
we are a light weight tag</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.remote">
<h2>Remote<a class="headerlink" href="#module-git.remote" title="Permalink to this headline">¶</a></h2>
<p>Module implementing a remote object allowing easy access to git remotes</p>
<dl class="class">
<dt id="git.remote.FetchInfo">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">FetchInfo</tt><big>(</big><em>ref</em>, <em>flags</em>, <em>note=''</em>, <em>old_commit=None</em><big>)</big><a class="headerlink" href="#git.remote.FetchInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Carries information about the results of a fetch operation of a single head:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">fetch</span><span class="p">()[</span><span class="mf">0</span><span class="p">]</span>
<span class="n">info</span><span class="o">.</span><span class="n">ref</span>           <span class="c"># Symbolic Reference or RemoteReference to the changed </span>
                   <span class="c"># remote head or FETCH_HEAD</span>
<span class="n">info</span><span class="o">.</span><span class="n">flags</span>         <span class="c"># additional flags to be &amp; with enumeration members, </span>
                   <span class="c"># i.e. info.flags &amp; info.REJECTED </span>
                   <span class="c"># is 0 if ref is SymbolicReference</span>
<span class="n">info</span><span class="o">.</span><span class="n">note</span>          <span class="c"># additional notes given by git-fetch intended for the user</span>
<span class="n">info</span><span class="o">.</span><span class="n">old_commit</span>    <span class="c"># if info.flags &amp; info.FORCED_UPDATE|info.FAST_FORWARD, </span>
                   <span class="c"># field is set to the previous location of ref, otherwise None</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.remote.FetchInfo.commit">
<tt class="descname">commit</tt><a class="headerlink" href="#git.remote.FetchInfo.commit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Commit of our remote ref</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.flags">
<tt class="descname">flags</tt><a class="headerlink" href="#git.remote.FetchInfo.flags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.remote.FetchInfo.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Name of our remote ref</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.note">
<tt class="descname">note</tt><a class="headerlink" href="#git.remote.FetchInfo.note" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.old_commit">
<tt class="descname">old_commit</tt><a class="headerlink" href="#git.remote.FetchInfo.old_commit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.FetchInfo.ref">
<tt class="descname">ref</tt><a class="headerlink" href="#git.remote.FetchInfo.ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.PushInfo">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">PushInfo</tt><big>(</big><em>flags</em>, <em>local_ref</em>, <em>remote_ref_string</em>, <em>remote</em>, <em>old_commit=None</em>, <em>summary=''</em><big>)</big><a class="headerlink" href="#git.remote.PushInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Carries information about the result of a push operation of a single head:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">push</span><span class="p">()[</span><span class="mf">0</span><span class="p">]</span>
<span class="n">info</span><span class="o">.</span><span class="n">flags</span>          <span class="c"># bitflags providing more information about the result</span>
<span class="n">info</span><span class="o">.</span><span class="n">local_ref</span>      <span class="c"># Reference pointing to the local reference that was pushed</span>
                    <span class="c"># It is None if the ref was deleted.</span>
<span class="n">info</span><span class="o">.</span><span class="n">remote_ref_string</span> <span class="c"># path to the remote reference located on the remote side</span>
<span class="n">info</span><span class="o">.</span><span class="n">remote_ref</span> <span class="c"># Remote Reference on the local side corresponding to </span>
                <span class="c"># the remote_ref_string. It can be a TagReference as well.</span>
<span class="n">info</span><span class="o">.</span><span class="n">old_commit</span> <span class="c"># commit at which the remote_ref was standing before we pushed</span>
                <span class="c"># it to local_ref.commit. Will be None if an error was indicated</span>
<span class="n">info</span><span class="o">.</span><span class="n">summary</span>    <span class="c"># summary line providing human readable english text about the push</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="git.remote.PushInfo.flags">
<tt class="descname">flags</tt><a class="headerlink" href="#git.remote.PushInfo.flags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.local_ref">
<tt class="descname">local_ref</tt><a class="headerlink" href="#git.remote.PushInfo.local_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.old_commit">
<tt class="descname">old_commit</tt><a class="headerlink" href="#git.remote.PushInfo.old_commit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.remote_ref">
<tt class="descname">remote_ref</tt><a class="headerlink" href="#git.remote.PushInfo.remote_ref" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Remote Reference or TagReference in the local repository corresponding 
to the remote_ref_string kept in this instance.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.remote_ref_string">
<tt class="descname">remote_ref_string</tt><a class="headerlink" href="#git.remote.PushInfo.remote_ref_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.remote.PushInfo.summary">
<tt class="descname">summary</tt><a class="headerlink" href="#git.remote.PushInfo.summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.Remote">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">Remote</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides easy read and write access to a git remote.</p>
<p>Everything not part of this interface is considered an option for the current 
remote, allowing constructs like remote.pushurl to query the pushurl.</p>
<p>NOTE: When querying configuration, the configuration accessor will be cached
to speed up subsequent accesses.</p>
<dl class="classmethod">
<dt id="git.remote.Remote.add">
<em class="property">classmethod </em><tt class="descname">add</tt><big>(</big><em>repo</em>, <em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote to the given repository
<tt class="docutils literal"><span class="pre">repo</span></tt></p>
<blockquote>
Repository instance that is to receive the new remote</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt></dt>
<dd>Desired name of the remote</dd>
<dt><tt class="docutils literal"><span class="pre">url</span></tt></dt>
<dd>URL which corresponds to the remote&#8217;s name</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments to be passed to the git-remote add command</dd>
<dt>Returns</dt>
<dd>New Remote instance</dd>
<dt>Raise</dt>
<dd>GitCommandError in case an origin with that name already exists</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.config_reader">
<tt class="descname">config_reader</tt><a class="headerlink" href="#git.remote.Remote.config_reader" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>GitConfigParser compatible object able to read options for only our remote.
Hence you may simple type config.get(&#8220;pushurl&#8221;) to obtain the information</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.config_writer">
<tt class="descname">config_writer</tt><a class="headerlink" href="#git.remote.Remote.config_writer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>GitConfigParser compatible object able to write options for this remote.</dd>
<dt>Note</dt>
<dd><p class="first">You can only own one writer at a time - delete it to release the 
configuration file and make it useable by others.</p>
<p class="last">To assure consistent results, you should only query options through the 
writer. Once you are done writing, you are free to use the config reader 
once again.</p>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>repo</em>, <em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote to the given repository
<tt class="docutils literal"><span class="pre">repo</span></tt></p>
<blockquote>
Repository instance that is to receive the new remote</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt></dt>
<dd>Desired name of the remote</dd>
<dt><tt class="docutils literal"><span class="pre">url</span></tt></dt>
<dd>URL which corresponds to the remote&#8217;s name</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments to be passed to the git-remote add command</dd>
<dt>Returns</dt>
<dd>New Remote instance</dd>
<dt>Raise</dt>
<dd>GitCommandError in case an origin with that name already exists</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.fetch">
<tt class="descname">fetch</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch the latest changes for this remote</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">refspec</span></tt></dt>
<dd><p class="first">A &#8220;refspec&#8221; is used by fetch and push to describe the mapping 
between remote ref and local ref. They are combined with a colon in 
the format &lt;src&gt;:&lt;dst&gt;, preceded by an optional plus sign, +. 
For example: git fetch $URL refs/heads/master:refs/heads/origin means 
&#8220;grab the master branch head from the $URL and store it as my origin 
branch head&#8221;. And git push $URL refs/heads/master:refs/heads/to-upstream 
means &#8220;publish my master branch head as to-upstream branch at $URL&#8221;. 
See also git-push(1).</p>
<p class="last">Taken from the git manual</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">progress</span></tt></dt>
<dd>See &#8216;push&#8217; method</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments to be passed to git-fetch</dd>
<dt>Returns</dt>
<dd>IterableList(FetchInfo, ...) list of FetchInfo instances providing detailed 
information about the fetch results</dd>
<dt>Note</dt>
<dd>As fetch does not provide progress information to non-ttys, we cannot make 
it available here unfortunately as in the &#8216;push&#8217; method.</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em><big>)</big><a class="headerlink" href="#git.remote.Remote.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Iterator yielding Remote objects of the given repository</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.name">
<tt class="descname">name</tt><a class="headerlink" href="#git.remote.Remote.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.remote.Remote.pull">
<tt class="descname">pull</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.pull" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull changes from the given branch, being the same as a fetch followed 
by a merge of branch with your local branch.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">refspec</span></tt></dt>
<dd>see &#8216;fetch&#8217; method</dd>
<dt><tt class="docutils literal"><span class="pre">progress</span></tt></dt>
<dd>see &#8216;push&#8217; method</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments to be passed to git-pull</dd>
<dt>Returns</dt>
<dd>Please see &#8216;fetch&#8217; method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.push">
<tt class="descname">push</tt><big>(</big><em>refspec=None</em>, <em>progress=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push changes from source branch in refspec to target branch in refspec.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">refspec</span></tt></dt>
<dd>see &#8216;fetch&#8217; method</dd>
<dt><tt class="docutils literal"><span class="pre">progress</span></tt></dt>
<dd>Instance of type RemoteProgress allowing the caller to receive 
progress information until the method returns.
If None, progress information will be discarded</dd>
<dt><tt class="docutils literal"><span class="pre">**kwargs</span></tt></dt>
<dd>Additional arguments to be passed to git-push</dd>
<dt>Returns</dt>
<dd>IterableList(PushInfo, ...) iterable list of PushInfo instances, each 
one informing about an individual head which had been updated on the remote 
side.
If the push contains rejected heads, these will have the PushInfo.ERROR bit set
in their flags.
If the operation fails completely, the length of the returned IterableList will
be null.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.refs">
<tt class="descname">refs</tt><a class="headerlink" href="#git.remote.Remote.refs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd><p class="first">IterableList of RemoteReference objects. It is prefixed, allowing 
you to omit the remote path portion, i.e.:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">remote</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">master</span> <span class="c"># yields RemoteReference(&#39;/refs/remotes/origin/master&#39;)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.remove">
<em class="property">classmethod </em><tt class="descname">remove</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.remove" title="Permalink to this definition">¶</a></dt>
<dd>Remove the remote with the given name</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.rename">
<tt class="descname">rename</tt><big>(</big><em>new_name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename self to the given new_name</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.repo">
<tt class="descname">repo</tt><a class="headerlink" href="#git.remote.Remote.repo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="git.remote.Remote.rm">
<em class="property">classmethod </em><tt class="descname">rm</tt><big>(</big><em>repo</em>, <em>name</em><big>)</big><a class="headerlink" href="#git.remote.Remote.rm" title="Permalink to this definition">¶</a></dt>
<dd>Remove the remote with the given name</dd></dl>

<dl class="attribute">
<dt id="git.remote.Remote.stale_refs">
<tt class="descname">stale_refs</tt><a class="headerlink" href="#git.remote.Remote.stale_refs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns </dt>
<dd><p class="first">IterableList RemoteReference objects that do not have a corresponding 
head in the remote reference anymore as they have been deleted on the 
remote side, but are still available locally.</p>
<p class="last">The IterableList is prefixed, hence the &#8216;origin&#8217; must be omitted. See
&#8216;refs&#8217; property for an example.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.remote.Remote.update">
<tt class="descname">update</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#git.remote.Remote.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch all changes for this remote, including new branches which will 
be forced in ( in case your local remote branch is not part the new remote branches
ancestry anymore ).</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional arguments passed to git-remote update</dd>
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.remote.RemoteProgress">
<em class="property">class </em><tt class="descclassname">git.remote.</tt><tt class="descname">RemoteProgress</tt><a class="headerlink" href="#git.remote.RemoteProgress" title="Permalink to this definition">¶</a></dt>
<dd><p>Handler providing an interface to parse progress information emitted by git-push
and git-fetch and to dispatch callbacks allowing subclasses to react to the progress.</p>
<dl class="method">
<dt id="git.remote.RemoteProgress.line_dropped">
<tt class="descname">line_dropped</tt><big>(</big><em>line</em><big>)</big><a class="headerlink" href="#git.remote.RemoteProgress.line_dropped" title="Permalink to this definition">¶</a></dt>
<dd>Called whenever a line could not be understood and was therefore dropped.</dd></dl>

<dl class="method">
<dt id="git.remote.RemoteProgress.update">
<tt class="descname">update</tt><big>(</big><em>op_code</em>, <em>cur_count</em>, <em>max_count=None</em>, <em>message=''</em><big>)</big><a class="headerlink" href="#git.remote.RemoteProgress.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the progress changes</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">op_code</span></tt></dt>
<dd><p class="first">Integer allowing to be compared against Operation IDs and stage IDs.</p>
<p>Stage IDs are BEGIN and END. BEGIN will only be set once for each Operation 
ID as well as END. It may be that BEGIN and END are set at once in case only
one progress message was emitted due to the speed of the operation.
Between BEGIN and END, none of these flags will be set</p>
<p class="last">Operation IDs are all held within the OP_MASK. Only one Operation ID will 
be active per call.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cur_count</span></tt></dt>
<dd>Current absolute count of items</dd>
<dt><tt class="docutils literal"><span class="pre">max_count</span></tt></dt>
<dd>The maximum count of items we expect. It may be None in case there is 
no maximum number of items or if it is (yet) unknown.</dd>
<dt><tt class="docutils literal"><span class="pre">message</span></tt></dt>
<dd>In case of the &#8216;WRITING&#8217; operation, it contains the amount of bytes
transferred. It may possibly be used for other purposes as well.</dd>
</dl>
<p>You may read the contents of the current line in self._cur_line</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.repo">
<h2>Repo<a class="headerlink" href="#module-git.repo" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.repo.Repo">
<em class="property">class </em><tt class="descclassname">git.repo.</tt><tt class="descname">Repo</tt><big>(</big><em>path=None</em><big>)</big><a class="headerlink" href="#git.repo.Repo" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a git repository and allows you to query references, 
gather commit information, generate diffs, create and clone repositories query
the log.</p>
<p>The following attributes are worth using:</p>
<p>&#8216;working_dir&#8217; is the working directory of the git command, wich is the working tree 
directory if available or the .git directory in case of bare repositories</p>
<p>&#8216;working_tree_dir&#8217; is the working tree directory, but will raise AssertionError
if we are a bare repository.</p>
<p>&#8216;git_dir&#8217; is the .git repository directoy, which is always set.</p>
<dl class="attribute">
<dt id="git.repo.Repo.active_branch">
<tt class="descname">active_branch</tt><a class="headerlink" href="#git.repo.Repo.active_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the currently active branch.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>Head to the active branch</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.alternates">
<tt class="descname">alternates</tt><a class="headerlink" href="#git.repo.Repo.alternates" title="Permalink to this definition">¶</a></dt>
<dd>Retrieve a list of alternates paths or set a list paths to be used as alternates</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.archive">
<tt class="descname">archive</tt><big>(</big><em>ostream</em>, <em>treeish=None</em>, <em>prefix=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Archive the tree at the given revision.
<tt class="docutils literal"><span class="pre">ostream</span></tt></p>
<blockquote>
file compatible stream object to which the archive will be written</blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">treeish</span></tt></dt>
<dd>is the treeish name/id, defaults to active branch</dd>
<dt><tt class="docutils literal"><span class="pre">prefix</span></tt></dt>
<dd>is the optional prefix to prepend to each filename in the archive</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional arguments passed to git-archive
NOTE: Use the &#8216;format&#8217; argument to define the kind of format. Use 
specialized ostreams to write any format supported by python</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span><span class="o">.</span><span class="n">archive</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;archive&quot;</span><span class="p">))</span>
<span class="go">&lt;String containing tar.gz archive&gt;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Raise</dt>
<dd>GitCommandError in case something went wrong</dd>
<dt>Returns</dt>
<dd>self</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.bare">
<tt class="descname">bare</tt><a class="headerlink" href="#git.repo.Repo.bare" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>True if the repository is bare</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.blame">
<tt class="descname">blame</tt><big>(</big><em>rev</em>, <em>file</em><big>)</big><a class="headerlink" href="#git.repo.Repo.blame" title="Permalink to this definition">¶</a></dt>
<dd><p>The blame information for the given file at the given revision.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">rev</span></tt></dt>
<dd>revision specifier, see git-rev-parse for viable options.</dd>
<dt>Returns</dt>
<dd>list: [git.Commit, list: [&lt;line&gt;]]
A list of tuples associating a Commit object with a list of lines that 
changed within the given commit. The Commit objects will be given in order
of appearance.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.branches">
<tt class="descname">branches</tt><a class="headerlink" href="#git.repo.Repo.branches" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <tt class="docutils literal"><span class="pre">Head</span></tt> objects representing the branch heads in
this repo</p>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.IterableList(Head,</span> <span class="pre">...)</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.clone">
<tt class="descname">clone</tt><big>(</big><em>path</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a clone from this repository.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>is the full path of the new repo (traditionally ends with ./&lt;name&gt;.git).</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>keyword arguments to be given to the git-clone command</dd>
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.Repo</span></tt> (the newly cloned repo)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.commit">
<tt class="descname">commit</tt><big>(</big><em>rev=None</em><big>)</big><a class="headerlink" href="#git.repo.Repo.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>The Commit object for the specified revision</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">rev</span></tt></dt>
<dd>revision specifier, see git-rev-parse for viable options.</dd>
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.Commit</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.config_reader">
<tt class="descname">config_reader</tt><big>(</big><em>config_level=None</em><big>)</big><a class="headerlink" href="#git.repo.Repo.config_reader" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd><p class="first">GitConfigParser allowing to read the full git configuration, but not to write it</p>
<p>The configuration will include values from the system, user and repository 
configuration files.</p>
<p class="last">NOTE: On windows, system configuration cannot currently be read as the path is 
unknown, instead the global path will be used.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">config_level</span></tt></dt>
<dd>For possible values, see config_writer method
If None, all applicable levels will be used. Specify a level in case 
you know which exact file you whish to read to prevent reading multiple files for 
instance</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.config_writer">
<tt class="descname">config_writer</tt><big>(</big><em>config_level='repository'</em><big>)</big><a class="headerlink" href="#git.repo.Repo.config_writer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>GitConfigParser allowing to write values of the specified configuration file level.
Config writers should be retrieved, used to change the configuration ,and written 
right away as they will lock the configuration file in question and prevent other&#8217;s
to write it.</dd>
<dt><tt class="docutils literal"><span class="pre">config_level</span></tt></dt>
<dd>One of the following values
system = sytem wide configuration file
global = user level configuration file
repository = configuration file for this repostory only</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.create_head">
<tt class="descname">create_head</tt><big>(</big><em>path</em>, <em>commit='HEAD'</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.create_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new head within the repository.</p>
<p>For more documentation, please see the Head.create method.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>newly created Head Reference</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.create_remote">
<tt class="descname">create_remote</tt><big>(</big><em>name</em>, <em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.create_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new remote.</p>
<p>For more information, please see the documentation of the Remote.create 
methods</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>Remote reference</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.create_tag">
<tt class="descname">create_tag</tt><big>(</big><em>path</em>, <em>ref='HEAD'</em>, <em>message=None</em>, <em>force=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.create_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new tag reference.</p>
<p>For more documentation, please see the TagReference.create method.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>TagReference object</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.daemon_export">
<tt class="descname">daemon_export</tt><a class="headerlink" href="#git.repo.Repo.daemon_export" title="Permalink to this definition">¶</a></dt>
<dd>If True, git-daemon may export this repository</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.delete_head">
<tt class="descname">delete_head</tt><big>(</big><em>*heads</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.delete_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given heads</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Additional keyword arguments to be passed to git-branch</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.delete_remote">
<tt class="descname">delete_remote</tt><big>(</big><em>remote</em><big>)</big><a class="headerlink" href="#git.repo.Repo.delete_remote" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given remote.</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.delete_tag">
<tt class="descname">delete_tag</tt><big>(</big><em>*tags</em><big>)</big><a class="headerlink" href="#git.repo.Repo.delete_tag" title="Permalink to this definition">¶</a></dt>
<dd>Delete the given tag references</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.description">
<tt class="descname">description</tt><a class="headerlink" href="#git.repo.Repo.description" title="Permalink to this definition">¶</a></dt>
<dd>the project&#8217;s description</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.git">
<tt class="descname">git</tt><a class="headerlink" href="#git.repo.Repo.git" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.git_dir">
<tt class="descname">git_dir</tt><a class="headerlink" href="#git.repo.Repo.git_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.head">
<tt class="descname">head</tt><a class="headerlink" href="#git.repo.Repo.head" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>HEAD Object pointing to the current head reference</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.heads">
<tt class="descname">heads</tt><a class="headerlink" href="#git.repo.Repo.heads" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <tt class="docutils literal"><span class="pre">Head</span></tt> objects representing the branch heads in
this repo</p>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.IterableList(Head,</span> <span class="pre">...)</span></tt></dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.index">
<tt class="descname">index</tt><a class="headerlink" href="#git.repo.Repo.index" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>IndexFile representing this repository&#8217;s index.</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="git.repo.Repo.init">
<em class="property">classmethod </em><tt class="descname">init</tt><big>(</big><em>path=None</em>, <em>mkdir=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a git repository at the given path if specified</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>is the full path to the repo (traditionally ends with /&lt;name&gt;.git)
or None in which case the repository will be created in the current 
working directory</dd>
<dt><tt class="docutils literal"><span class="pre">mkdir</span></tt></dt>
<dd>if specified will create the repository directory if it doesn&#8217;t
already exists. Creates the directory with a mode=0755. 
Only effective if a path is explicitly given</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>keyword arguments serving as additional options to the git-init command</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">git</span><span class="o">.</span><span class="n">Repo</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="s">&#39;/var/git/myrepo.git&#39;</span><span class="p">,</span><span class="n">bare</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.Repo</span></tt> (the newly created repo)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.is_dirty">
<tt class="descname">is_dirty</tt><big>(</big><em>index=True</em>, <em>working_tree=True</em>, <em>untracked_files=False</em><big>)</big><a class="headerlink" href="#git.repo.Repo.is_dirty" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd><tt class="xref docutils literal"><span class="pre">True</span></tt>, the repository is considered dirty. By default it will react
like a git-status without untracked files, hence it is dirty if the 
index or the working copy have changes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.iter_commits">
<tt class="descname">iter_commits</tt><big>(</big><em>rev=None</em>, <em>paths=''</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.iter_commits" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Commit objects representing the history of a given ref/commit</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">rev</span></tt></dt>
<dd><blockquote class="first">
revision specifier, see git-rev-parse for viable options.
If None, the active branch will be used.</blockquote>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">paths</span></tt></dt>
<dd>is an optional path or a list of paths to limit the returned commits to
Commits that do not contain that path or the paths will not be returned.</dd>
<dt><tt class="docutils literal"><span class="pre">kwargs</span></tt></dt>
<dd>Arguments to be passed to git-rev-list - common ones are 
max_count and skip</dd>
</dl>
</dd>
</dl>
<p>Note: to receive only commits between two named revisions, use the 
&#8220;revA..revB&#8221; revision specifier</p>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.Commit[]</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.iter_trees">
<tt class="descname">iter_trees</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.repo.Repo.iter_trees" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>Iterator yielding Tree objects</dd>
</dl>
<p>Note: Takes all arguments known to iter_commits method</p>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.references">
<tt class="descname">references</tt><a class="headerlink" href="#git.repo.Repo.references" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Reference objects representing tags, heads and remote references.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>IterableList(Reference, ...)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.refs">
<tt class="descname">refs</tt><a class="headerlink" href="#git.repo.Repo.refs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Reference objects representing tags, heads and remote references.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>IterableList(Reference, ...)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.remote">
<tt class="descname">remote</tt><big>(</big><em>name='origin'</em><big>)</big><a class="headerlink" href="#git.repo.Repo.remote" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>Remote with the specified name</dd>
<dt>Raise </dt>
<dd>ValueError if no remote with such a name exists</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.remotes">
<tt class="descname">remotes</tt><a class="headerlink" href="#git.repo.Repo.remotes" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Remote objects allowing to access and manipulate remotes</p>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.IterableList(Remote,</span> <span class="pre">...)</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.tag">
<tt class="descname">tag</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.repo.Repo.tag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return</dt>
<dd>TagReference Object, reference pointing to a Commit or Tag</dd>
<dt><tt class="docutils literal"><span class="pre">path</span></tt></dt>
<dd>path to the tag reference, i.e. 0.1.5 or tags/0.1.5</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.tags">
<tt class="descname">tags</tt><a class="headerlink" href="#git.repo.Repo.tags" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <tt class="docutils literal"><span class="pre">Tag</span></tt> objects that are available in this repo</p>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.IterableList(TagReference,</span> <span class="pre">...)</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="git.repo.Repo.tree">
<tt class="descname">tree</tt><big>(</big><em>rev=None</em><big>)</big><a class="headerlink" href="#git.repo.Repo.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tree object for the given treeish revision</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">rev</span></tt></dt>
<dd>is a revision pointing to a Treeish ( being a commit or tree )</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">repo</span><span class="o">.</span><span class="n">tree</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Returns</dt>
<dd><tt class="docutils literal"><span class="pre">git.Tree</span></tt></dd>
<dt>NOTE</dt>
<dd>If you need a non-root level tree, find it by iterating the root tree. Otherwise
it cannot know about its path relative to the repository root and subsequent 
operations might have unexpected results.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.untracked_files">
<tt class="descname">untracked_files</tt><a class="headerlink" href="#git.repo.Repo.untracked_files" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd><p class="first">list(str,...)</p>
<p class="last">Files currently untracked as they have not been staged yet. Paths 
are relative to the current working directory of the git command.</p>
</dd>
<dt>Note</dt>
<dd>ignored files will not appear here, i.e. files mentioned in .gitignore</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.working_dir">
<tt class="descname">working_dir</tt><a class="headerlink" href="#git.repo.Repo.working_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.repo.Repo.working_tree_dir">
<tt class="descname">working_tree_dir</tt><a class="headerlink" href="#git.repo.Repo.working_tree_dir" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns</dt>
<dd>The working tree directory of our git repository</dd>
<dt>Raises AssertionError</dt>
<dd>If we are a bare repository</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.repo.is_git_dir">
<tt class="descclassname">git.repo.</tt><tt class="descname">is_git_dir</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#git.repo.is_git_dir" title="Permalink to this definition">¶</a></dt>
<dd>This is taken from the git setup.c:is_git_directory
function.</dd></dl>

<dl class="function">
<dt id="git.repo.touch">
<tt class="descclassname">git.repo.</tt><tt class="descname">touch</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#git.repo.touch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-git.stats">
<h2>Stats<a class="headerlink" href="#module-git.stats" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.stats.Stats">
<em class="property">class </em><tt class="descclassname">git.stats.</tt><tt class="descname">Stats</tt><big>(</big><em>total</em>, <em>files</em><big>)</big><a class="headerlink" href="#git.stats.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents stat information as presented by git at the end of a merge. It is 
created from the output of a diff operation.</p>
<p><tt class="docutils literal"><span class="pre">Example</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">Commit</span><span class="p">(</span> <span class="n">sha1</span> <span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stats</span>
<span class="n">s</span><span class="o">.</span><span class="n">total</span>         <span class="c"># full-stat-dict</span>
<span class="n">s</span><span class="o">.</span><span class="n">files</span>         <span class="c"># dict( filepath : stat-dict )</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">stat-dict</span></tt></p>
<p>A dictionary with the following keys and values:</p>
<div class="highlight-python"><pre>deletions = number of deleted lines as int
insertions = number of inserted lines as int
lines = total number of lines changed as int, or deletions + insertions</pre>
</div>
<p><tt class="docutils literal"><span class="pre">full-stat-dict</span></tt></p>
<p>In addition to the items in the stat-dict, it features additional information:</p>
<div class="highlight-python"><pre>files = number of changed files as int</pre>
</div>
<dl class="attribute">
<dt id="git.stats.Stats.files">
<tt class="descname">files</tt><a class="headerlink" href="#git.stats.Stats.files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.stats.Stats.total">
<tt class="descname">total</tt><a class="headerlink" href="#git.stats.Stats.total" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-git.utils">
<h2>Utils<a class="headerlink" href="#module-git.utils" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="git.utils.BlockingLockFile">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">BlockingLockFile</tt><big>(</big><em>file_path</em>, <em>check_interval_s=0.29999999999999999</em>, <em>max_block_time_s=9223372036854775807</em><big>)</big><a class="headerlink" href="#git.utils.BlockingLockFile" title="Permalink to this definition">¶</a></dt>
<dd>The lock file will block until a lock could be obtained, or fail after 
a specified timeout</dd></dl>

<dl class="class">
<dt id="git.utils.ConcurrentWriteOperation">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">ConcurrentWriteOperation</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#git.utils.ConcurrentWriteOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>This class facilitates a safe write operation to a file on disk such that we:</p>
<blockquote>
<ul class="simple">
<li>lock the original file</li>
<li>write to a temporary file</li>
<li>rename temporary file back to the original one on close</li>
<li>unlock the original file</li>
</ul>
</blockquote>
<p>This type handles error correctly in that it will assure a consistent state 
on destruction</p>
</dd></dl>

<dl class="class">
<dt id="git.utils.Iterable">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">Iterable</tt><a class="headerlink" href="#git.utils.Iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an interface for iterable items which is to assure a uniform 
way to retrieve and iterate items within the git repository</p>
<dl class="classmethod">
<dt id="git.utils.Iterable.iter_items">
<em class="property">classmethod </em><tt class="descname">iter_items</tt><big>(</big><em>repo</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.utils.Iterable.iter_items" title="Permalink to this definition">¶</a></dt>
<dd><p>For more information about the arguments, see list_items
Return:</p>
<blockquote>
iterator yielding Items</blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="git.utils.Iterable.list_items">
<em class="property">classmethod </em><tt class="descname">list_items</tt><big>(</big><em>repo</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#git.utils.Iterable.list_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all items of this type - subclasses can specify args and kwargs differently.
If no args are given, subclasses are obliged to return all items if no additional 
arguments arg given.</p>
<p>Note: Favor the iter_items method as it will</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list(Item,...) list of item instances</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="git.utils.IterableList">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">IterableList</tt><big>(</big><em>id_attr</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#git.utils.IterableList" title="Permalink to this definition">¶</a></dt>
<dd><p>List of iterable objects allowing to query an object by id or by named index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heads</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">heads</span>
<span class="n">heads</span><span class="o">.</span><span class="n">master</span>
<span class="n">heads</span><span class="p">[</span><span class="s">&#39;master&#39;</span><span class="p">]</span>
<span class="n">heads</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</pre></div>
</div>
<p>It requires an id_attribute name to be set which will be queried from its 
contained items to have a means for comparison.</p>
<p>A prefix can be specified which is to be used in case the id returned by the 
items always contains a prefix that does not matter to the user, so it 
can be left out.</p>
</dd></dl>

<dl class="class">
<dt id="git.utils.LazyMixin">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">LazyMixin</tt><a class="headerlink" href="#git.utils.LazyMixin" title="Permalink to this definition">¶</a></dt>
<dd>Base class providing an interface to lazily retrieve attribute values upon 
first access. If slots are used, memory will only be reserved once the attribute
is actually accessed and retrieved the first time. All future accesses will 
return the cached value as stored in the Instance&#8217;s dict or slot.</dd></dl>

<dl class="class">
<dt id="git.utils.LockFile">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">LockFile</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#git.utils.LockFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides methods to obtain, check for, and release a file based lock which 
should be used to handle concurrent access to the same file.</p>
<p>As we are a utility class to be derived from, we only use protected methods.</p>
<p>Locks will automatically be released on destruction</p>
</dd></dl>

<dl class="class">
<dt id="git.utils.SHA1Writer">
<em class="property">class </em><tt class="descclassname">git.utils.</tt><tt class="descname">SHA1Writer</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#git.utils.SHA1Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around a file-like object that remembers the SHA1 of 
the data written to it. It will write a sha when the stream is closed
or if the asked for explicitly usign write_sha.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Based on the dulwich project</dd>
</dl>
<dl class="method">
<dt id="git.utils.SHA1Writer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#git.utils.SHA1Writer.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.utils.SHA1Writer.f">
<tt class="descname">f</tt><a class="headerlink" href="#git.utils.SHA1Writer.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="git.utils.SHA1Writer.sha1">
<tt class="descname">sha1</tt><a class="headerlink" href="#git.utils.SHA1Writer.sha1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.utils.SHA1Writer.tell">
<tt class="descname">tell</tt><big>(</big><big>)</big><a class="headerlink" href="#git.utils.SHA1Writer.tell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.utils.SHA1Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#git.utils.SHA1Writer.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="git.utils.SHA1Writer.write_sha">
<tt class="descname">write_sha</tt><big>(</big><big>)</big><a class="headerlink" href="#git.utils.SHA1Writer.write_sha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="git.utils.join_path">
<tt class="descclassname">git.utils.</tt><tt class="descname">join_path</tt><big>(</big><em>a</em>, <em>*p</em><big>)</big><a class="headerlink" href="#git.utils.join_path" title="Permalink to this definition">¶</a></dt>
<dd>Join path tokens together similar to os.path.join, but always use 
&#8216;/&#8217; instead of possibly &#8216;&#8217; on windows.</dd></dl>

<dl class="function">
<dt id="git.utils.join_path_native">
<tt class="descclassname">git.utils.</tt><tt class="descname">join_path_native</tt><big>(</big><em>a</em>, <em>*p</em><big>)</big><a class="headerlink" href="#git.utils.join_path_native" title="Permalink to this definition">¶</a></dt>
<dd>As join path, but makes sure an OS native path is returned. This is only 
needed to play it safe on my dear windows and to assure nice paths that only 
use &#8216;&#8217;</dd></dl>

<dl class="function">
<dt id="git.utils.make_sha">
<tt class="descclassname">git.utils.</tt><tt class="descname">make_sha</tt><big>(</big><em>source=''</em><big>)</big><a class="headerlink" href="#git.utils.make_sha" title="Permalink to this definition">¶</a></dt>
<dd><p>A python2.4 workaround for the sha/hashlib module fiasco</p>
<dl class="docutils">
<dt>Note</dt>
<dd>From the dulwich project</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="git.utils.to_native_path">
<tt class="descclassname">git.utils.</tt><tt class="descname">to_native_path</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.utils.to_native_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="git.utils.to_native_path_linux">
<tt class="descclassname">git.utils.</tt><tt class="descname">to_native_path_linux</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.utils.to_native_path_linux" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="git.utils.to_native_path_windows">
<tt class="descclassname">git.utils.</tt><tt class="descname">to_native_path_windows</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#git.utils.to_native_path_windows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">API Reference</a><ul>
<li><a class="reference external" href="#module-git.actor">Actor</a></li>
<li><a class="reference external" href="#module-git.objects.base">Objects.Base</a></li>
<li><a class="reference external" href="#module-git.objects.blob">Objects.Blob</a></li>
<li><a class="reference external" href="#module-git.objects.commit">Objects.Commit</a></li>
<li><a class="reference external" href="#module-git.objects.tag">Objects.Tag</a></li>
<li><a class="reference external" href="#module-git.objects.tree">Objects.Tree</a></li>
<li><a class="reference external" href="#module-git.objects.utils">Objects.Utils</a></li>
<li><a class="reference external" href="#module-git.cmd">GitCmd</a></li>
<li><a class="reference external" href="#module-git.config">Config</a></li>
<li><a class="reference external" href="#module-git.diff">Diff</a></li>
<li><a class="reference external" href="#module-git.errors">Errors</a></li>
<li><a class="reference external" href="#module-git.index">Index</a></li>
<li><a class="reference external" href="#module-git.refs">Refs</a></li>
<li><a class="reference external" href="#module-git.remote">Remote</a></li>
<li><a class="reference external" href="#module-git.repo">Repo</a></li>
<li><a class="reference external" href="#module-git.stats">Stats</a></li>
<li><a class="reference external" href="#module-git.utils">Utils</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="tutorial.html"
                                  title="previous chapter">GitPython Tutorial</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="roadmap.html"
                                  title="next chapter">Roadmap</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/reference.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="roadmap.html" title="Roadmap"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="GitPython Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">GitPython v0.2.0 Beta documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright Copyright (C) 2008, 2009 Michael Trier and contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>